---
title: "Happiness and European Parliament - Adventures in European Social Survey Data"
author: "Juha Riissanen - juhariis@gmail.com"
date: "2018-09-13"
output:
  github_document:
    toc: yes
    toc_depth: 4
always_allow_html: yes
params:
  html_wo_widget: FALSE
  explore_indicator_graphs: TRUE
  explore_country_graphs: TRUE
---

* * *

This workbook is used to create content for the 
blog post on [investigation of European Social Study](https://hidingindata.wordpress.com/2018/06/20/happiness-and-european-parliament-adventures-in-european-social-survey-data/). 
(HTLM version to show off active content via [Rpubs](http://www.rpubs.com/juhariis/ess) and 
[Azure](https://juhariis.z16.web.core.windows.net/EuropeanSocialSurvey.html). 
Since Rpubs seems to have some size limitations, the exploratory graphs on indicators and 
countries are not included.
Current Azure subscription has not these limitations so there we have all content.
But loading of the page may take some time..)

* * * 

Europe is going through interesting time since turn of the century:
Brexit, refugee crisis, rise of populism, economic worries, rising tensions 
between the West and Russia - and a lot  more 
[Timeline of 21st century](https://en.wikipedia.org/wiki/Timeline_of_the_21st_century)

European Social Study has been collecting data on people in most countries 
in Europe every two years since 2002. The purpose of this study is look into the recent history
of Europe mainlywith the help of ESS data.
As additional data we will use World Bank Development indicator set and 
a data set from UNHCR to provide some reference to ESS indicators.

We started by looking into subjective happiness, how it has changed over time
and investigated what factors in ESS data are associated with it by using
linear modeling.

From that we continued looking into other indicators which either were 
significantly associated with subjective happiness or otherwise were seen as 
interesting and important items for this study

* how helpful other people are perceived, 
* trust in United Nations, 
* trust in European Parliament,
* views in immigration from poor areas outside of Europe

Finally, we used Primary Component Analysis and k-means clustering
to find best number of country clusters based on their similarity 
in the selected ESS variables.

Findings

* subjective happiness
    * there is a border of subjective happiness levels running across Europe
    diagonally from South West corner of Portugal to Eastern border of Finland, 
    likely more resulting from cultural biases and values of countries than 
    from genuine differences in "true absolute" happiness
    * for Poland and Slovenia the change in happiness from 2002 to 2016 
    and from 2014 to 2016 was statistically significant but not very 
    meaningful (effect size according to Cohen's d was 'small')
    * changes for other countries had the effect size "neglible" or had no 
    statistical significance
* trust in European Parliament
    * Hungary, Greece, Ukraine, 
    have seen trust fluctuating strongly 
    * United Kingdom had statistically significant rise from 2014 to 2016, 
    which could be linked to some second thoughts 
    in the aftermath of the Brexit vote (fieldwork in the UK was 
    conducted after the vote 01.09.16-20.03.17)
* other findings
    * poor subjective happiness scores seem to be somewhat correlated 
    with countries with low scores on question willingness of people to help others
    (no correlation study was done, but visually on maps there seems to be
    rough correspondence)
    * overall feedback on further integration of EU seem to have shifted 
    towards "not more"
    * acceptance of immigration from poor countries outside of Europe
    is significantly lower in Hungary than most other countries (even though
    Cyprus and Greece are not that far from it, their latest scores are several years 
    old)
    * and significantly higher in Sweden that in other countries..
* participating countries were clustered into two groups using PCA and k-means
    * Nordic countries + Benelux + Ireland + Swizerland + Austria vs. the rest
    * the clustering seems justified when comparing individual ESS indicator scores
    by the groups
    
Several historic events can be see in the data

* Greece crisis - the data set ends in 2010 when the support package was agreed, 
trust in European Parliament plummeted
* Ukraine - the data does not go into the timeframe of Criomean annexation, but
may reflect the ups and downs of the country in the first decade of 2000's
* United Kingdom - aftermath of the Brexit vote might somehow be reflected
in the increased trust on European Parliament 
* Hungary having high expectations in European Parliament before joining EU, trust
dropped significantly by end of the survey period
* Worldwide economic crisis in 2008

Combined data set has several interesting features which may be source of some future
blog posts, especially 

* correlating UNHCR and WB data with ESS
* identifying discussion topics in European Parliament over the changes in some indicators

* * *

## European Social Survey

As described in the abstract of its eighth round (conducted 2016-2017)

>The European Social Survey (ESS) is an academically-driven multi-country survey, which has been administered in over 30 countries to date. Its three aims are, firstly – to monitor and interpret changing public attitudes and values within Europe and to investigate how they interact with Europe's changing institutions, secondly - to advance and consolidate improved methods of cross-national survey measurement in Europe and beyond, and thirdly - to develop a series of European social indicators, including attitudinal indicators. 
>
>In the eighth round, the survey covers 23 countries and employs the most rigorous methodologies. From Round 7 it is funded by the Members, Observers and Guests of ESS European Research Infrastructure Consortium (ESS ERIC) who represent national governments. Participating countries directly fund the central coordination costs of the ESS ERIC, as well the costs of fieldwork and national coordination in their own country. 
>
>The survey involves strict random probability sampling, a minimum target response rate of 70% and rigorous translation protocols. The hour-long face-to-face interview includes questions on a variety of core topics repeated from previous rounds of the survey and also two modules developed for Round 8 covering Public Attitudes to Climate Change, Energy Security, and Energy Preferences and Welfare Attitudes in a Changing Europe (the latter is a partial repeat of a module from Round 4).

In total there are over 500 indicators. 
However, all of them are not collected in all surveys, countries or 
in each interview.

Use of dataset is free for use as stated in ESS codebook

> The data are available without restrictions, for not-for-profit purposes

Starting point for this investigation is the question on subjective happiness

> Taking all things together, how happy would you say you are?

resulting in the indicator `happy` with range from zero (Extremely unhappy) 
to ten (Extremely happy).

* * *

**Setup**

```{r, message=FALSE}
# load key libraries
library(ggplot2)
library(dplyr)
library(tidyr)
library(reshape2)
library(car)
library(Hmisc)
library(corrplot)
library(countrycode)
library(ggrepel)
library(GGally)
library(ggiraph)       # Interactive plot versions for ggplot2
library(viridis)       # red-green colour blind compatible palettes


# must set false for github_markup 
plot_wo_widget <- params$html_wo_widget

source("ess_subs.r")

my_data_folder = "C:\\Users\\Juha\\Documents\\MyData\\"

# reference p-value for statistics

p_val = 0.05

```

## ESS Data

Main dataset used in this investigation covers the period 2002-2016.
It was created merging a 2002-2014 dataset created with 
[ESS Cumulative Data Wizard](http://www.europeansocialsurvey.org/downloadwizard/) 
and
a [separately downloaded 2016 set](http://nesstar.ess.nsd.uib.no/webview/) 
since the latter was not in the wizard at the time.

### Raw Data

Reading and merging ESS survey data from the two downloaded sets and keeping only those 
indicators which are in both.

```{r}
dataset = GetData(data_folder = my_data_folder, use_rds = TRUE)
dim(dataset)
names(dataset)

```

So, the dataset contains at this point over 376 000 rows and almost 230 columns.
Variable details available in ESS codebook.

### Survey coverage

We know from ESS portal already that all countries have not been in all surveys

```{r, warning=FALSE}
# survey coverage
ds_participations <- dataset %>% 
  group_by(cntry_name, ess_year) %>%
  summarise(n=n()) %>%
  mutate(n_ave = mean(n, na.rm = TRUE),
         first_year = min(ess_year),
         last_year = max(ess_year),
         n_surveys = n()) %>% 
  spread(ess_year, n)

# On geographic map
p <- CreateEuroMap(dsin = ds_participations %>% ungroup(), 
                   ind_name = "n_surveys",
                   txt_title = "Participation in surveys",
                   txt_subtitle = "Number of surveys a country has participated in",
                   txt_caption = "ESS surveys 2002-2016")
MyPrintInteractive(p, plot_wo_widget)

```

So, there is a band of countries starting from Finland in the north eastern corner of Europe,
stretching all the way to Spain and Portugal in the far south western corner,
which have been in all or nearly all surveys.

```{r}
p <- ggplot(data=ds_participations, 
            aes(x=reorder(cntry_name, n_surveys))) +
  geom_bar_interactive(stat="identity", fill="grey", aes(y=n_surveys, tooltip=paste0(cntry_name, '\n', n_surveys))) +
  labs(
    title="Participation in surveys",
    subtitle="Number of surveys a country has participated in",
    caption="ESS surveys 2002-2016") + 
  xlab("") + ylab("")+
  theme(plot.title = element_text(hjust = 0),
        plot.subtitle = element_text(hjust = 0)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5))

MyPrintInteractive(p, plot_wo_widget)

# creating a caption for table so that it can be referenced in the text later on
# ref https://datascienceplus.com/r-markdown-how-to-number-and-reference-tables/

tab.1_cap <- table_nums(name = "tab_1", 
             caption = "Summary of countries participating the survey, including count of responses each year")

```
`r table_nums('tab_1')`
```{r table1, fig.cap=tab.1_cap}
knitr::kable(ds_participations,
             digits = 0,
             col.names = gsub("_", " ", colnames(ds_participations)))
```

### Weights

Data has to be weighted for analysis as pointed out in ESS material

> Note In general, you must weight tables before quoting percentages from them. To apply weights, select the Weight icon and choose one or more weight variables to use. The Design weights (DWEIGHT) adjust for different selection probabilities, while the Post-stratification weights (PSPWGHT) adjust for sampling error and non-response bias as well as different selection probabilities. Either DWEIGHT or PSPWGHT must always be used. In addition, the Population size weights (PWEIGHT) should be applied if you are looking at aggregates or averages for two or more countries combined. Please see the guide Weighting European Social Survey Data for fuller details about how to use the weights.

We will use `pspwght`
post stratification weighting which
attempts to take into account varying response rates in different population groups.

The weights do vary quite a bit, from almost zero all the way up to close to
seven, meaning that a response can essentially vote on behalf of almost seven
persons and another practically none, as illustrated in the following 
graph.

```{r}
p <- ggplot(data = dataset, aes(pspwght)) +
  geom_histogram(bins = 200, fill = 'gray') +
  geom_vline(
    xintercept = quantile(dataset$pspwght),
    linetype = "dashed",
    color = "black") +
  annotate(
    "label",
    label = names(quantile(dataset$pspwght)),
    x = quantile(dataset$pspwght),
    y = 19000,           # fixed by experimentation
    size = 2) +
  labs(
    title = "Weighting of survey data",
    subtitle = "Distribution of 'pspwght' across all surveys, highlighting quantiles",
    caption = "ESS surveys 2002-2016") +
  theme(plot.title = element_text(hjust = 0),
        plot.subtitle = element_text(hjust = 0)) +
  xlab("") + ylab("")
print(p)

```

* * *

## Subjective Happiness

First indicator we are interested in is subjective happiness, `happy` 
and will consider other indicators later on

Questions

* how has subjective happiness evolved over the time
* are there significant changes differences between countries

### Pre-processing

Checking data

```{r}
summary(dataset$happy)
```

Some pre-processing needed since valid
range is 0-10.

In ESS data - as described in their codebook - missing responses, refusal to 
answer, etc are  encoded using numbers outside of the normal range of an indicator.
And these vary depending on indicator.

So, for `happy` we will filter out responses with higher than 10 score since
they are not relevant for this study

* 77 - Refusal
* 88 - Don't know
* 99 - No answer

We replace the higher than 10 values for happy with NA

```{r}

dataset$happy[dataset$happy > 10] <- NA

# creating new dataset for by country and by survey average of happy 
# by excluding missing data and calculating weighted means
ds_happy_ave <- dataset %>% 
  filter(!is.na(happy)) %>%
  group_by(ess_year, cntry_name) %>% 
  summarise(var_ave = Hmisc::wtd.mean(happy, pspwght),
            n=sum(pspwght))

```

Making a diagnostic plot to verify that the weighted scores land 
into the expected range of `happy`.

```{r}

# get skewness of the distribution 
happy_skew <- moments::skewness(ds_happy_ave$var_ave)

ggplot(data=ds_happy_ave, aes(var_ave)) +
  geom_histogram(bins = 15, fill='gray') +
  geom_vline(xintercept = quantile(ds_happy_ave$var_ave), linetype="dashed", color="black") +
  annotate("label", label=names(quantile(ds_happy_ave$var_ave)), 
           x=quantile(ds_happy_ave$var_ave), y=2, size=2) +
  labs(
    title="Subjective happiness",
    subtitle="Weighted by survey/country scores",
    caption="ESS surveys 2002-2016") +
  theme(plot.title = element_text(hjust = 0),
        plot.subtitle = element_text(hjust = 0)) +
  xlab("") + ylab("")

summary(ds_happy_ave$var_ave)

```

And that indeed is the case, producing a clearly left skewed 
distribution (`r round(happy_skew,3)`).

Some countries have been in all 
surveys and some in only two.
So there are no big conclusions to be drawn at this stage.

### How is happiness distributed in Europe

Next we investigate the average scores by country on geographic map to 
see if there are any patterns.

```{r, warning=FALSE}

ds_happy_avgsum <- MakeAverageSummary(ds = ds_happy_ave, value_term = "var_ave")

p <- CreateEuroMap(dsin = ds_happy_avgsum %>%
                     filter(cntry_name != "Mean"), 
                   ind_name = "var_ave",
                   txt_title = "Subjective happiness 2002-2016",
                   txt_subtitle = "Average score of 'happy', scale 0-10",
                   txt_caption = "ESS surveys 2002-2016")
MyPrintInteractive(p, TRUE) 

```

Europe seems to be divided into two areas and a border zone running
diagonally from South West to North East.
With Portugal and Israel exceptions to that pattern.

This divide might be a result of different cultural traditions and norms 
refleced in how people score personal happiness. 
Therefore, comparing absolute scores between the countries might 
actually be misleading.

An alternative would be to compare each country by itself, i.e. has the 
personal assesment of happiness improved or not compared to past in that 
same country.

### Changes of happiness by country and survey

Next we will show average of `happy` by country for each survey
as a heatmap ordered by decreasing average happiness (calculated
over all surveys a country has participated in).

```{r, warning=FALSE}

p_happy <- MakeIndicatorHeatSet(
   ds = ds_happy_avgsum, 
   value_term = "var_ave", 
   txt_name = "Subjective happiness",
   txt_subtitle = "Average score of 'happy', scale 0-10",
   txt_caption = "ESS surveys 2002-2016")

MyPrintInteractive(p_happy, plot_wo_widget) 

```

Note that mean across columns and rows is a simple average over the 
scores shown on the table.

Since each ESS survey often has had different number of countries the averages over columns
cannot be used for any meaningful trend evaluation.

Especially as the lowest means seem to correspond to surveys where Turkey, Ukraine and Bulgaria 
were participating.
And these countries are clearly in the overall lower end of subjective happiness spectrum
in ESS.

### Trends in happiness

Subsequent expoloration / analysis will be conducted with the countries whih have been in at least 
four of the surveys because that allows inclusion of certain - in the light of recent European 
history - very interesting countries like Greece, Italy, Russia and Ukraine.
Iceland, Croatia, Turkey and LUxembourg are excluded as they have been in three or two surveys only.

This will mean that there can be some additional level of error in the results.
So, the mean drawn in the following chart has some limitations.

```{r, warning=FALSE}

# Countries in 4 or more of the surveys

cntry_in_50pct <- (ds_participations %>% 
                     filter(n_surveys>=4) %>% 
                     select(cntry_name))$cntry_name

trends_happy_50  <- MakeIndicatorCountryPlot(
    ds = ds_happy_ave %>% 
      filter(cntry_name %in% cntry_in_50pct) %>%
      mutate(explain_txt = cntry_name), 
    id_term = "var_ave",
    cntry_term = "cntry_name",
    cntry_term_long = "explain_txt",
    year_term = "ess_year",
    txt_head = "Subjective happiness",
    txt_subhead = "Countries in 50% of surveys or more",
    txt_caption = "ESS surveys 2002-2016",
    show_summary = TRUE,
    plevel = p_val)

MyPrintInteractive(trends_happy_50$ci, plot_wo_widget, 
                   hover_css = "stroke-width:3px;") 


```

For comparison we show the graph where all included countries have been in all surveys.
In this case the average line is a bit more meaningful - but we miss quite 
a few interesting countries.

```{r, warning=FALSE}

# countries in all surveys

cntry_in_100pct <- (ds_participations %>% 
                     filter(n_surveys==8) %>% 
                     select(cntry_name))$cntry_name

trends_happy_100  <- MakeIndicatorCountryPlot(
  ds = ds_happy_ave %>% 
    filter(cntry_name %in% cntry_in_100pct) %>%
    mutate(explain_txt = cntry_name), 
  id_term = "var_ave",
  cntry_term = "cntry_name",
  cntry_term_long = "explain_txt",
  year_term = "ess_year",
  txt_head = "Subjective happiness",
  txt_subhead = "Countries in all surveys",
  txt_caption = "ESS surveys 2002-2016",
  show_summary = TRUE,
  plevel = p_val)

MyPrintInteractive(trends_happy_100$ci, plot_wo_widget, 
                   hover_css = "stroke-width:3px;") 

```

There are quite varied happiness histories on display.
In one end countries like Finland, Swizerland, Norway and Denmark
are almost monotonically in the high end of the scale.

And then there are countries like Hungary, 
Poland, Ireland and Portugal where happiness has taken big swiup and down.

Unfortunately the data from most recent but very interestig time is completely 
missing for some, 
e.g. Greece (the debt crisis, refugees after 2010) and Ukraine (annexation of Crimea 2014).

### Variations

Heatmap and line graph above indicate some variation of scores between surveys.
That is more visible in the plot below where we include all countries

```{r}

p <- ggplot(data = ds_happy_avgsum %>% filter(ess_year=="Mean", cntry_name != "Mean"),
            aes(x=reorder(cntry_name, var_ave))) +
  geom_point_interactive(data=ds_happy_ave, 
                         aes(y=var_ave, color=as.factor(ess_year),
                             tooltip = paste0(cntry_name, " ", ess_year, 
                                              "\nScore: ", round(var_ave,2)))) +
  geom_point_interactive(aes(y=var_ave,
                             tooltip = paste0(cntry_name, 
                                              "\nMean: ", round(var_ave,2))), 
                         color="black", pch=5) +
  labs(title="Subjective happiness scores",
       subtitle="All countries in order of decreasing mean (black diamond)",
       caption = "ESS surveys 2002-2016") +
  scale_color_viridis(discrete=TRUE) +
  theme(axis.title=element_blank(),
        plot.title = element_text(hjust = 0),
        plot.subtitle = element_text(hjust = 0)) +
  labs(color="ESS Year") +
  coord_flip()

MyPrintInteractive(p, plot_wo_widget) 

```

For some countries there is quite wide variation in the scores between surveys.
But in general it looks like those on the high end of happiness have had less 
variation than those on the lower end.

```{r}
ds_happy_sd <- ds_happy_ave %>% 
  group_by(cntry_name) %>% 
  dplyr::summarize(sd = sd(var_ave), n=n()) %>% 
  mutate(cntry_name2 = paste0(cntry_name, " (",n,")")) %>%
  arrange(desc(sd))

p <- ggplot(data=ds_happy_sd, aes(x=reorder(cntry_name2, sd), y=sd, fill=n)) +
  geom_bar_interactive(aes(tooltip=paste0(cntry_name, "\nSurveys: ", n, "\nSD: ", round(sd,2))),stat = "identity") + 
  coord_flip() +
  labs(title="Standard deviation of 'happy'",
       subtitle="All countries, number of surveys in parenthesis",
       caption="ESS surveys 2002-2016") +
  scale_color_viridis(discrete=TRUE) +
  theme(axis.title=element_blank(),
        plot.title = element_text(hjust = 0),
        plot.subtitle = element_text(hjust = 0)) 

MyPrintInteractive(p, plot_wo_widget) 

```


### Significance and meaning of changes

There is a visual suggestion that subjective happiness may have improved
for several countries over the past
couple of surveys.

So, we will check the significance of the change from 2002 to 2016 as well as from  
2014 to 2016 using weighted t-test for each country separately.

Note the significance levels coded in symbols

| symbol | level |
|:------:|:-----:|
|   ***  | 0.001 |
|   **   | 0.01  |
|   *    | 0.05  |
|   +    | 0.1   |
|        | 1     |

And we will check if the change was meaningful - having a meaningful effect - using
Cohen's d metric.

```{r, message=FALSE, warning=FALSE}
happy_res <- GetComparisonBoxPlot(indval_name =  "happy", 
                                  ds_avg = ds_happy_avgsum %>% select(-n), 
                                  ds = dataset %>% filter(!is.na(happy)),
                                  cntry_list = cntry_in_100pct,
                                  txt_name = "Subjective happiness", 
                                  txt_subtitle= "", 
                                  txt_caption="ESS 2002-2016",
                                  skip_plot = FALSE)

tab.2_cap <- table_nums(name="tab_2",
                        caption = "Changes of subjective happiness 2002 vs 2016 and 2014 vs 2016 with p-values for significance of the change, Cohen's d values for effect size")
```
`r table_nums("tab_2")`
```{r table2, fig.cap=tab.2_cap}
knitr::kable(happy_res$table, digits = 3,
             col.names = gsub("_", " ", colnames(happy_res$table)))

```

```{r}

MyPrintInteractive(happy_res$plot, plot_wo_widget) 

```


The box-plots are in line with t-test results shown in table `r f.ref("tab_2")`.
But only a couple of the changes was meaningful according to COhen's d measure, and even the
the effect was only small.

But perhaps that is acceptable in a survey like this.
The situation would be quite different if we were looking for an impact coming from a 
controlled experiment.

Next we check a few individual cases to get better understanding of data.

```{r}

cowplot::plot_grid(
  PlotIndicatorHistogram(dataset, "Finland", 2002, "happy"),
  PlotIndicatorHistogram(dataset, "Finland", 2012, "happy"), 
  PlotIndicatorHistogram(dataset, "Finland", 2016, "happy"), 
  PlotIndicatorHistogram(dataset, "Switzerland", 2016, "happy"), 
  ncol = 2)

cowplot::plot_grid(
  PlotIndicatorHistogram(dataset, "Poland", 2012, "happy"),
  PlotIndicatorHistogram(dataset, "France", 2002, "happy"),
  PlotIndicatorHistogram(dataset, "France", 2012, "happy"), 
  PlotIndicatorHistogram(dataset, "France", 2014, "happy"), 
  ncol = 2)

```

Skew can be strong, as can be seen in the histograms above.. 

However, the sample counts used in t-tests are quite large, as shown in 
`r f.ref("tab_1")`, so the results should be fairly accurate.


### Trends on standardized scale

Previous calculation was made using the weighted absolute values reported.
It is possible that there are cultural biases between countries in using 
the scale from zero to ten.

So, perhaps a better question is: How much has subjective happiness in a country 
changed when measured with respect to its own variation history.

As we have seen that the distribution of `happy` is strongly left skewed, we will make
a few transformations to better handle the situation and

* reflect the scores to get from left skewed to right skewed distributions
* apply log transformation to dampen or remove the strong skew
* scale scores of each country

#### Reflect and log transform

First, we check what do a few reflected and log 
transformed distributions look like in histograms.
These are the same samples used above.

```{r}

cowplot::plot_grid(
  PlotIndicatorHistogram(dataset, "Finland", 2002, "happy", 
                         use_transform = "ReflectLn"),
  PlotIndicatorHistogram(dataset, "Finland", 2012, "happy", 
                         use_transform = "ReflectLn"), 
  PlotIndicatorHistogram(dataset, "Finland", 2016, "happy", 
                         use_transform = "ReflectLn"), 
  PlotIndicatorHistogram(dataset, "Switzerland", 2016, "happy", 
                         use_transform = "ReflectLn"), 
  ncol = 2)

cowplot::plot_grid(
  PlotIndicatorHistogram(dataset, "Poland", 2012, "happy", 
                         use_transform = "ReflectLn"), 
  PlotIndicatorHistogram(dataset, "France", 2002, "happy", 
                         use_transform = "ReflectLn"), 
  PlotIndicatorHistogram(dataset, "France", 2012, "happy", 
                         use_transform = "ReflectLn"), 
  PlotIndicatorHistogram(dataset, "France", 2014, "happy", 
                         use_transform = "ReflectLn"), 
  ncol = 2)

```

It is clear that the distributions are more normal-like and skew 
reduced.

Therefore, we will transform and normalize the responses by country to 
be able to compare changes in a comparable scale.
The assumption is that some countries may naturally wider and some smaller
variations, perhaps due to cultural reasons.
In essence we amplify changes in countries with narrow variation range and
decrease those with wide.

```{r}


# convert to "inverted ln" 
dataset$happy_invln <- NA
idx <- which(!is.na(dataset$happy))
dataset$happy_invln[idx] <- ReflectLnTransform(dataset$happy[idx])
summary(dataset[dataset$happy <=10 , c("happy_invln", "happy")])

```

#### Scale

Next we scale the transformed scores and multiply by -1 to get back to 
the original meaning of the metric where smaller number means less happy 
and larger more.

```{r}

# scale and change positive to mean increase in the original sense
dataset_scaled <- dataset %>%
  filter(!is.na(happy_invln)) %>%
  group_by(cntry_name) %>%
  mutate(happy_std = -scale(happy_invln)) %>%
  ungroup()


```

Sample of the scaled distributions

```{r}
# some samples
cowplot::plot_grid(
  PlotIndicatorHistogram(dataset_scaled, "Finland", 2002, "happy_std"),
  PlotIndicatorHistogram(dataset_scaled, "Finland", 2012, "happy_std"), 
  PlotIndicatorHistogram(dataset_scaled, "Finland", 2016, "happy_std"), 
  PlotIndicatorHistogram(dataset_scaled, "Switzerland", 2016, "happy_std"), 
  ncol = 2)


```

#### Trends of transformed and scaled happiness

Calculate the results from the scaled data

```{r, warning=FALSE}
# filtering and weighting to get by year and by country scores
ds_happy_scaled <- dataset_scaled %>% 
  group_by(ess_year, cntry_name) %>% 
  summarise(var_ave = Hmisc::wtd.mean(happy_std, pspwght),
            n=sum(pspwght))

# plot trends
trends_happy_50_scaled  <- MakeIndicatorCountryPlot(
    ds = ds_happy_scaled %>% 
      filter(cntry_name %in% cntry_in_50pct) %>%
      mutate(explain_txt = cntry_name), 
    id_term = "var_ave",
    cntry_term = "cntry_name",
    cntry_term_long = "explain_txt",
    year_term = "ess_year",
    txt_head = "Subjective happiness",
    txt_subhead = "Scaled and normalized - Countries in 50% of surveys or more",
    txt_caption = "ESS surveys 2002-2016",
    show_summary = TRUE,
    plevel = p_val)

MyPrintInteractive(trends_happy_50_scaled$ci, plot_wo_widget, 
                   hover_css = "stroke-width:3px;") 


```

Some notes

* in the beginning and in the end the scorea are widely spread
* there may region of smaller variation somewhere in 2008-2012
* Portugal seems skyrocketing in the final ESS survey

Next showing changes using scaled range for the countries with 
significant changes according to `r f.ref("tab_2")`

```{r, message=FALSE, warning=FALSE}

ds_happy_average_scaled <- MakeAverageSummary(
  ds = ds_happy_scaled, 
  value_term = "var_ave")

happy_res_scaled <- GetComparisonBoxPlot(
  indval_name =  "happy_std", 
  ds_avg = ds_happy_average_scaled %>% select(-n), 
  ds = dataset_scaled %>% 
    filter(!is.na(happy_invln)),
  cntry_list = cntry_in_100pct,
  skip_plot = TRUE)

p <- CreateEuroMap(dsin = happy_res_scaled$table %>%
                     filter(cntry_name %in% (happy_res$table %>%
                                               filter(p_0216 <= p_val))$cntry_name), 
                   ind_name = "d0216",
                   txt_title = "Significant change in subjective happiness",
                   txt_subtitle = "2002 vs 2016, countries in all surveys, standardized, p=0.05",
                   txt_caption = "ESS 2002-2016")
MyPrintInteractive(p, plot_wo_widget) 

p <- CreateEuroMap(dsin = happy_res_scaled$table %>%
                     filter(cntry_name %in% (happy_res$table %>%
                                               filter(p_1416 <= p_val))$cntry_name), 
                   ind_name = "d1416",
                   txt_title = "Significant change in subjective happiness",
                   txt_subtitle = "2014 vs 2016, countries in all surveys, standardized, p=0.05",
                   txt_caption = "ESS 2002-2016")
MyPrintInteractive(p, plot_wo_widget) 


```

Given that the effect size as calculated by Cohen's d has been mostly "insignificant",
interpretation of the charts is a bit clouded.

Thwen again, this is not a controlled study where we try to judge if treatment A was 
more effective than treatment B for selecting which drug to invest in..

So, the chages are there in their level of significance as per frequentist way of work.

### Wrapup and what next

So, there are changes that are statistically significant even if their 
effect is small or even neglible.

We have a few hundred additional indicators in ESS dataset.
Do we have anything there which has association or correlation with 
subjective happiness?

* * *

## Happiness and associations

Subjective happiness varies and has trends - sort of at least.

The next question is: are there significant associations with 
subjective happiness and othedr ESS variabkes

We pick a few additional indicators which - quite subjectively - seem 
like they could be associated with feeling of happiness.
In a way or another.

Additional indicators mainly for context taken from 

* World Bank Development Indicators
* UNHCR population data on refugees and asylum seekers
* European Union - dates of joining

These might be used in a more formal as part of analysis way later.

Scoping to the countries which have been in 50% or more of the surveys 
(four or more out of the eight surveys).

And just as a reminder, it is about associations and correlations only.
Not possible to go into honest discussion about causality based on the data available.

```{r get_ds_subset_50}

ds_subset_50 <- dataset %>% 
  filter(cntry_name %in% cntry_in_50pct)

```

### ESS indicators

Granted, whole ESS dataset contains many more and the selection made here and now 
has no hard scientific basis.
However, they seem intuitively such which might be related to 
subjective happiness.

The indicators chosen

```{r}
# get indicators and their descriptions from a file which is easier to maintain than
# writing the same into R-code

metadata_columns <- c("cntry_name","ess_year", "idno", "pspwght")
indicator_table <- readxl::read_excel("codemap.xlsx")
ess_indicators <- union(metadata_columns, 
                        as.character((indicator_table %>% filter(source=="ESS"))$indicator))
knitr::kable(indicator_table, caption = "ESS indicators along with their ranges")

```

The following might be candidates at later stage, but we will start with those above

* `brncntr`	Born in country	All rounds: Were you born in [country]?
* `gndr` - Gender	All rounds: CODE SEX, respondent
* `yrbrn`	- Year of birth	All rounds: And in what year were you born?
* `agea` - Age of respondent, calculated	All rounds: Age of respondent, calculated

```{r}

ds_subset_50 <- ds_subset_50 %>%
  select(which(colnames(dataset) %in% ess_indicators))
print(dim(ds_subset_50))

```

#### Pre-processing

As with `happy` earlier, there is the need to make some adjustments 
to get a better usable set of data for analysis.
Using min/max rules from the definition file.

```{r}

# marking excluded data as NA

print("Before")

summary(ds_subset_50[, indicator_table$indicator])

for (i in 1:nrow(indicator_table)){
  an_ind <- indicator_table[i,]
  #print(an_ind$indicator)
  # print(head(ds_subset_50[,indicator_table$indicator[i]]))
  ds_subset_50[,an_ind$indicator] <- ifelse(
    ds_subset_50[,an_ind$indicator] > an_ind$max
    | ds_subset_50[,an_ind$indicator] < an_ind$min, 
    NA, 
    ds_subset_50[,an_ind$indicator])
}

print("After")
summary(ds_subset_50[, indicator_table$indicator])

```

### Shape of distributions

Showing the shape of all indicators, excluding metadata columns 
to help understand the data better.

```{r}

GetMinMaxLabel <- function(ind_name, indicator_table){
  this_ind <- indicator_table %>% filter(indicator==ind_name)
  if (!is.na(this_ind$lblmin)){
    minmax_label <- paste(this_ind$lblmin, this_ind$min, 
                         '<-->', 
                         this_ind$lblmax, this_ind$max)
  }else {
    minmax_label <- ""
  }
  #print(minmax_label)
  return(minmax_label)
}

ind_plots <- lapply(
  setdiff(colnames(ds_subset_50), metadata_columns), 
  function(x, ds){
    ds$tmp_filter <- ds[,x]
    PlotIndicatorHistogram(ds %>% 
                             filter(!is.na(tmp_filter)), 
                           "", 
                           NA, 
                           x, 
                           n_bins = as.integer(max(ds$tmp_filter, na.rm = TRUE)))
  }, 
  ds=ds_subset_50)

# no need to make these plots interactive - print as they are
for (i in 1:length(ind_plots))
  print(ind_plots[[i]])

```

Mostly the distributions at this level do not seem significantly skewed.

Concern: 
This could be an effect from averaging over all data and could hide potential 
time-dependent or country-dependent skew impacting later analysis.
However, at this stage we will assume that there are no issues that 
would require making elaborate transformations like what we
experimented with in the first analysis of `happy` earlier.
Perhaps later.


### Weights

Next we apply post stratification weights for the selected 
indicators to get meaningful averages.

```{r}

ds_subset_50_ave <- ds_subset_50 %>%
  gather(indicator, value, indicator_table$indicator) %>%
  filter(!is.na(value)) %>%
  group_by(cntry_name, ess_year, indicator) %>% 
  summarise(ave = Hmisc::wtd.mean(value, pspwght)) %>%
  spread(indicator, ave) %>%
  ungroup()

```

### Missing values

Checking the indicators.

```{r}

summary(ds_subset_50_ave %>% select(-cntry_name, -ess_year))

NA_columns <- ds_subset_50_ave %>% 
  select_if(function(x) any(is.na(x))) %>% 
  summarise_all(funs(sum(is.na(.)))) 
knitr::kable(NA_columns, caption = "Columns with NA entries")

txt_NA <- paste(colnames(NA_columns), collapse=", ")

```

Indicators `r txt_NA` have some missing values.
We will create new indicators where we fill in missing values by 
interpolation and/or use the first / last real value for missing 
beginning / end values.

Naturally, these are not the real thing anymore but should
be close enough for this analysis.

```{r}

# special case for Greece which has only one entry for eisced (education level)

Greece_eisced2 <- ds_subset_50_ave %>% 
  filter(cntry_name == "Greece", !is.na(eisced)) %>% 
  select(eisced)
if (nrow(Greece_eisced2) != 1) stop("Greece eisced assumption not valid")

# using zoo package to impute missing values

ds_subset_50_ave <- ds_subset_50_ave %>% 
  group_by(cntry_name) %>% 
  mutate(
    eisced2 = ifelse(cntry_name == "Greece",
                     as.numeric(Greece_eisced2$eisced[1]),
                     zoo::na.fill(eisced, "extend")),
    trstprt2 = zoo::na.fill(trstprt, "extend"),
    stfgov2 = zoo::na.fill(stfgov, "extend"),
    euftf2 = zoo::na.fill(euftf, "extend")) %>% 
  ungroup()

# Diagnostic to show what values were before/after imputation
# but as the table is fairly long, commented out now
# 
# cntry_imputed <- (ds_subset_50_ave %>% 
#                     filter(!complete.cases(.)) %>% 
#                     select(cntry_name) %>% 
#                     filter(!duplicated(cntry_name)))$cntry_name
# knitr::kable(ds_subset_50_ave %>% 
#                filter(cntry_name %in% cntry_imputed) %>%
#                select(cntry_name, ess_year, eisced, eisced2, trstprt, trstprt2, 
#                       stfgov, stfgov2, euftf, euftf2),
#              digits = 3,
#              caption = "Table of original and imputed values")

# removing the originals from the dataframe as they are not needed in the 
# subsequent work

ds_subset_50_ave <- ds_subset_50_ave %>%
  select(-eisced, -trstprt, -stfgov, -euftf)
  
```

#### Get rid of collinear variables

Since we intend to come up with a model we must remove indicators 
that are essentially the same,
i.e. indicators which have too high correlation and would really not add to the model
and would be in conflict with the requirements of linear modeling
we aim to do.

```{r address_collinearity}

coll_cutoff <- 0.9
print(paste("Cutoff level for correlation", coll_cutoff))

# exclude metadata indicators

df1 = ds_subset_50_ave %>% select(-ess_year, -cntry_name)
df2 = cor(df1)

# findCorrelation searches through a correlation matrix and returns a vector of 
# integers corresponding to columns to remove to reduce pair-wise correlations.

hc = caret::findCorrelation(
  df2, 
  cutoff=coll_cutoff, 
  verbose = TRUE,     # verbose helps to understand better what happens
  names = FALSE)
hc = sort(hc)

# summary
keep_table <- data.frame(
  rownr = 1:dim(df1)[2], 
  indicator = colnames(df1),
  keep = ifelse((1:dim(df1)[2]) %in% hc, 
                "drop", 
                "keep"),
  name = sapply(colnames(df1), function(x) GetIndicator(x, indicator_table)$name)
)

knitr::kable(keep_table, caption = "Features")

# the reduced data
reduced_Data = df1[,-c(hc)]

colnames_keep <- union(colnames(reduced_Data),c("ess_year","cntry_name"))
ds_subset_50_ave <- ds_subset_50_ave %>% select(colnames_keep)

```

#### Reshape

Turn dataset into narrow format for flexibility

```{r create_ds_ss_avg}

ds_ss_avg  <- ds_subset_50_ave %>% 
  gather(indicator, value, which(colnames(ds_subset_50_ave) %in% colnames(reduced_Data)))
print(dim(ds_ss_avg))


```

### World Bank

World Bank Development Indices provide a good backdrop and context for ESS.

Selecting a few which appear like they could be relevant in this context,
which suggests indicators related to migration, refugees and economical situation.

Again, this is fairly subjective selection and something important may be
missing.

Since the countries differ in size - and therefore the indicators as well - we 
use percentages and ratios when possible.

```{r get_wb_data, warning=FALSE}

wb_data <- GetPreProcessWbData(
  read_rds = TRUE, 
  inc_countries = unique(ds_ss_avg$cntry_name), 
  min_year = min(dataset$ess_year), 
  max_year = max(dataset$ess_year))

# merge 

ds_ss_avg <- ds_ss_avg %>%
  bind_rows(wb_data$data %>% 
              select(ess_year, cntry_name, indicator, value))

# add definitions
indicator_table <- indicator_table %>%
  bind_rows(wb_data$indicators)

knitr::kable(indicator_table %>% filter(source=="WB"), digits = 3)

```

For clarity 

* International migrant stock above means people who have been born in another country
* Refugees are different group of people than e.g. asylum seekers, which are not in World Bank dataset at all

For asylum seekers we need to turn to UNHCR

### UNHCR

Given that refugees and asylum seekers have been an important factor in the 
2000s Europe we need to get more data, which is available at UNHCR at 
[UNHCR Population Statistics - time series](http://popstats.unhcr.org/en/time_series)

Since World Bank and UNHCR data are not necessarily in full synch the numbers on 
refugees, which is available from both sources, is expected to be not exactly
the same.

Therefore we take refugees from World Bank and other "people of concern" groups 
from UNHCR

But first, we check what is in that UNHCR people of concern classification and how it has 
changed over 2000s.

```{r get_unhcr_data}

# take data from beginning of ess surveys

ds_unhcr <- GetUnhcrData(
  data_folder = my_data_folder, 
  inc_countries = unique(ds_ss_avg$cntry_name), 
  min_year = min(dataset$ess_year), 
  max_year = max(dataset$ess_year), 
  read_rds = TRUE)

p <- ggplot(data= ds_unhcr, 
            aes(x=ess_year, y=value, fill=pop_type, color=pop_type)) +
  geom_bar_interactive(stat="identity", 
                       aes(tooltip=paste(ess_year, pop_type))) +
  labs(title="People of concern in Europe",
       subtitle="Countries participating in ESS",
       caption="UNHCR") +
  xlab("") + ylab("")
MyPrintInteractive(p, plot_wo_widget)

```
So, a downwarsd trend turned into a sharp rise 2014 as - some might say - a thing hit the fan..

Some insigt - perhaps - from two snapshots, i.e. 2013 and 2016.

```{r}
p <- ggplot(data= ds_unhcr %>% filter(ess_year==2013), 
       aes(x=reorder(cntry_name, -value), y=value, fill=pop_type)) +
  geom_bar_interactive(stat="identity", 
                       aes(tooltip=paste(cntry_name,'-', pop_type))) +
  labs(title="People of concern in Europe 2013",
       subtitle="Countries participating in ESS",
       caption="UNHCR") +
  xlab("") + ylab("") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5))
MyPrintInteractive(p, plot_wo_widget)

p <- ggplot(data= ds_unhcr %>% filter(ess_year==2016), 
       aes(x=reorder(cntry_name, -value), y=value, fill=pop_type)) +
  geom_bar_interactive(stat="identity", 
                       aes(tooltip=paste(cntry_name, '-', pop_type))) +
  labs(title="People of concern in Europe 2016",
       subtitle="Countries participating in ESS",
       caption="UNHCR") +
  xlab("") + ylab("") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5))
MyPrintInteractive(p, plot_wo_widget)

```

Huge increase in "internally displaced persons" in Ukraine - yes, there was and still is 
that crisis regarding Crimea

Trying log10 scaler for y-axiz to get better view.

```{r}


p <- ggplot(data= ds_unhcr %>% filter(ess_year==2016), 
       aes(x=reorder(cntry_name, -value), y=(value+1), fill=pop_type)) +
  geom_bar_interactive(stat="identity", 
                       aes(tooltip=paste(cntry_name, '-', pop_type))) +
  labs(title="People of concern in Europe 2016",
       subtitle="Countries participating in ESS - log10 scale",
       caption="UNHCR") +
  xlab("") + ylab("") + 
  scale_y_log10() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5))
MyPrintInteractive(p, plot_wo_widget)
```



```{r}

# top 4 and all others

top_pop_types <- as.character((ds_unhcr %>% 
  group_by(pop_type) %>% 
  summarise(n = sum(value)) %>% 
  arrange(-n))$pop_type)

pop_type_major <- top_pop_types[1:4]
pop_type_other <- setdiff(top_pop_types, pop_type_major)

GetPplOfConcernSubset <- function(ds_unhr, wb_data, pop_set, new_indicator, new_name) {
  
  the_indicator <- paste0(
      "UNHCR.",
      ifelse(new_indicator=="", substr(pop_set[1], 1, 7), new_indicator),
      ".PCT")
  the_name = paste0(
      ifelse(new_name == "", pop_set[1], new_name), 
             "(% of population) - calculated")
  
  # print(pop_set)
  # print(the_indicator)
  # print(the_name)
  
  ds <- GetPreProcessUnhcrData(
    ds_unhcr = ds_unhcr %>%
      filter(pop_type %in% pop_set) %>%
      group_by(indicator, name, source, ess_year, cntry_name) %>%
      summarise(value = sum(value)) %>%
      ungroup(),
    ds_wb = wb_data$data,
    new_indicator = the_indicator,
    new_name = the_name)
  return(ds)  
}

unhcr_data <- NULL
unhcr_indicator_table <- NULL

for (pop_type in pop_type_major){
  ds_pop <- GetPplOfConcernSubset(ds_unhr, wb_data, pop_type, new_indicator="", new_name="")
  unhcr_data <- unhcr_data %>% bind_rows(ds_pop$data)
  unhcr_indicator_table <- unhcr_indicator_table %>% bind_rows(ds_pop$indicators)
}

ds_pop <- GetPplOfConcernSubset(ds_unhr, wb_data, pop_type_other, 
                                new_indicator="Other", 
                                new_name="Other population types together")
unhcr_data <- unhcr_data %>%
  bind_rows(ds_pop$data)
unhcr_indicator_table <- unhcr_indicator_table %>%
  bind_rows(ds_pop$indicators)


p <- ggplot(data=unhcr_data %>% filter(ess_year==2016), 
       aes(x=reorder(cntry_name, -value), y=value+1, fill=indicator)) +
  geom_bar_interactive(stat="identity", 
                       aes(tooltip=paste(cntry_name, '-', pop_type))) +
  labs(title="People of concern in Europe 2016",
       subtitle="% of population, log10 scale yaxis showing 1% more than real",
       caption="UNHCR") +
  xlab("") + ylab("") + 
  scale_y_log10() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5))
MyPrintInteractive(p, plot_wo_widget)

# merge data
ds_ss_avg <- ds_ss_avg %>%
  bind_rows(unhcr_data %>% 
              select(ess_year, cntry_name, indicator, value))

# merge definitions
indicator_table <- indicator_table %>%
  bind_rows(unhcr_indicator_table)

knitr::kable(indicator_table %>% filter(source=="UNHCR"), digits = 3)

```

Cross check with World Bank data

```{r}

# check WB vs UNHCR data

p <- ggplot(data = ds_ss_avg %>% 
         filter(indicator %in% c("UNHCR.Refugee.PCT","REFG.PCT"),
                ess_year==2016),
       aes(x=reorder(cntry_name, -value), y=value, fill=indicator)) +
  geom_bar_interactive(stat = "identity", position = "dodge", aes(tooltip=paste(cntry_name, indicator, round(value,2)))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5)) + 
  xlab("") + ylab("")

MyPrintInteractive(p, plot_wo_widget)
  
```

Looks good and reassuring.

### Pct indicators

There are big variations in the sizes of countries included.
Therefore looking into percentages is often more 
informative than absolute figures.

The following are indicators on percentages in World Bankand UNHCR data - or derived from them.  

```{r}

idx_pct <- grepl("%", indicator_table$name, fixed =TRUE)
pct_indicators <- indicator_table$indicator[idx_pct]
knitr::kable(indicator_table[idx_pct,], digits = 3)

```


```{r}

# save  a copies to be used by other scripts

saveRDS(indicator_table, file="indicator_table.rds")
saveRDS(ds_ss_avg, file="ds_ss_avg.rds")

ds_ss_avg_cntry_ind <- ds_ss_avg %>% 
  spread(indicator, value)

ds_ss_avg_ind_cntry <- ds_ss_avg %>% 
  spread(cntry_name, value)


```

## Explore Extended Data

Investiating and learning the extended ESS data set spiced up with World Bank and UNHCR data.

Note that an interactive version of the graphs below is available at the time
of writing as a
[shine application](https://juhariis.shinyapps.io/ess_shiny/) on web.

### By indicator

Checking first what we can learn from by indicator view, i.e.
how different are the trajectories of countries.
Are there any curious outliers?

```{r explore_indicators, warning=FALSE}

# need to construct a temporary rmd file which does not put javascript output inside 
# a loop construct - the temporary file gets read by the next chunk of the document

GetIndicatorPlotJs <- function(indicator_short, id, prefix) {
  # preparing an additional file to allow renderin of javascript, id and prefix not necessary
  c(
    " ",
    paste0("#### ", indicator_short),
    " ",
    "```{r, echo=FALSE, warning=FALSE}", 
    paste0("this_ind <- GetIndicator('", 
           indicator_short,
           "', indicator_table)"),
    paste0("p",prefix,id,"  <- MakeIndicatorCountryPlot("),
    "ds = ds_ss_avg_cntry_ind,",
    paste0("id_term = '",indicator_short,"',"),
    "cntry_term = 'cntry_name',",
    "year_term = 'ess_year',",
    "txt_head = as.character(this_ind$name),",
    "txt_subhead = indicator_short,",
    "txt_caption = paste(as.character(this_ind$source), '2002-2016'),",
    "show_summary = TRUE,",
    "plevel = p_val)",
    "if (!is.na(this_ind$lblmin)){",
    paste0("p",prefix,id,"$ci <- p",prefix,id,"$ci +"),
    "ylab(paste(this_ind$lblmin, this_ind$min, '<-->', this_ind$lblmax, this_ind$max)) +",
    "theme(axis.title.y = element_text(size = 7))",
    "}",
    paste0("MyPrintInteractive(p",prefix,id,"$ci, plot_wo_widget, hover_css = 'stroke-width:3px;') "),
    " ",
    "```", 
    " "
  )
}

if (params$explore_indicator_graphs){
  ascript <- NULL
  for (indicator_short in unique(ds_ss_avg$indicator)){
    ascript <- c(ascript, GetIndicatorPlotJs(indicator_short, length(ascript), "ind"))
  }
} else {
  ascript <- c("", "Exploratory graphs skipped to keep the document shorter.", " ")
}

tmp_indicators_rmd <- "tmp_indicators.rmd"
if (file.exists(tmp_indicators_rmd)) file.remove(tmp_indicators_rmd)
fileConn<-file(tmp_indicators_rmd)
writeLines(c(
  " ",
  ascript, 
  " "
  ), fileConn)
close(fileConn)

```

```{r indicators-active, child = 'tmp_indicators.Rmd'}
```


### By country

```{r, warning=FALSE}

GetCountryPlotJs <- function(cntry) {
  # preparing an additional file to allow rendering of javascript
  c(
    " ",
    paste0("#### ", cntry),
    "```{r, echo=FALSE, warning=FALSE}", 
    " ",
    "p_ess  <- MakeIndicatorCountryPlot(",
    "  ds = ds_ss_avg_ind_cntry %>% ",
    "    filter(indicator %in% (indicator_table %>% ",
    "                             filter(source=='ESS'))$indicator) %>% ",
    "left_join(indicator_table %>% ",
    paste0("            mutate(long_name = gsub('",   # need to get rid of quotation mark!!
           "\\'",
           "','',name, fixed=TRUE)) %>% "),
    "            select(indicator, long_name),",
    "          by='indicator'),",
    paste0("  id_term = '",cntry,"',"),
    "  cntry_term = 'indicator',",
    "  cntry_term_long = 'long_name',",
    "  year_term = 'ess_year',",
    paste0("  txt_head = '",cntry,"',"),
    "  txt_subhead = 'ESS survey indicators',",
    "  txt_caption = 'ESS 2002-2016',",
    "  show_summary = FALSE,",
    "  label_size_coef = lbl_coef,",
    "  plevel = p_val)",
    " ",
    "p_wb_a  <- MakeIndicatorCountryPlot(",
    "  ds = ds_ss_avg_ind_cntry %>% ",
    "    filter(indicator %in% (indicator_table[idx_pct,] %>% ",
    "                             filter(max > pct_max_split))$indicator) %>%",
    "left_join(indicator_table %>% ",
    "            mutate(long_name = name) %>% ",
    "            select(indicator, long_name),",
    "          by='indicator'),",
    paste0("  id_term = '",cntry,"',"),
    "  cntry_term = 'indicator',",
    "  cntry_term_long = 'long_name',",
    "  year_term = 'ess_year',",
    paste0("  txt_head = '",cntry,"',"),
    "  txt_subhead = 'World Bank Development Indices & UNHCR',",
    "  txt_caption = 'World Bank & UNHCR 2002-16',",
    "  show_summary = FALSE,",
    "  label_size_coef = lbl_coef,",
    "  plevel = p_val)",
    " ",
    "p_wb_b  <- MakeIndicatorCountryPlot(",
    "  ds = ds_ss_avg_ind_cntry %>% ",
    "    filter(indicator %in% (indicator_table[idx_pct,] %>% ",
    "                             filter(max <= pct_max_split))$indicator) %>%",
    "left_join(indicator_table %>% ",
    "            mutate(long_name = name) %>% ",
    "            select(indicator, long_name),",
    "          by='indicator'),",
    paste0("  id_term = '",cntry,"',"),
    "  cntry_term = 'indicator',",
    "  cntry_term_long = 'long_name',",
    "  year_term = 'ess_year',",
    paste0("  txt_head = '",cntry,"',"),
    "  txt_subhead = 'World Bank Development Indices & UNHCR',",
    "  txt_caption = 'World Bank & UNHCR 2002-16',",
    "  show_summary = FALSE,",
    "  label_size_coef = lbl_coef,",
    "  plevel = p_val)",
    " ",
    "MyPrintInteractive(p_ess$ci, plot_wo_widget, hover_css = 'stroke-width:3px;') ",
    "MyPrintInteractive(p_wb_a$ci, plot_wo_widget, hover_css = 'stroke-width:3px;') ",
    "MyPrintInteractive(p_wb_b$ci, plot_wo_widget, hover_css = 'stroke-width:3px;') ",
    "```", 
    " "
  )
}

lbl_coef <- 1
pct_max_split <- 30

if (params$explore_country_graphs){
  ascript <- NULL
  for (cntry in unique(ds_ss_avg$cntry_name)){
    ascript <- c(ascript, GetCountryPlotJs(cntry))
  } 
}else {
  ascript <- c("", "Exploratory graphs skipped to keep the document shorter.", " ")
}

tmp_countries_rmd <- "tmp_countries.rmd"
if (file.exists(tmp_countries_rmd)) file.remove(tmp_countries_rmd)
fileConn<-file(tmp_countries_rmd)
writeLines(c(
  "",
  ascript, 
  ""
  ), fileConn)
close(fileConn)

```

```{r countries-active, child = 'tmp_countries.Rmd'}
```



## Linear Modeling

We create a multiple linear regression model to get insight into associations 
between dependent and independent variables in our data.

As data we use the average scores of the indicators by country and by ESS survey.
We check the performance of the model with the results of the 2016 survey.

In creating the model we will not use the year of a survey as an element.
In other words, we assume that the relationship is independent of time.

At least for the time being.

### Assumptions

Using multivariate linear model which assumes
http://www.statisticssolutions.com/assumptions-of-multiple-linear-regression/

* linearity - linear relationship between dependent and independent variables
* multivariate normality - residuals are normally distributed
* no multicollinearity - independent variables are not highly correlated with each other
* homoskedasticity  - variance of error terms similar across the values of independent variables

The following pairwise correlation graph gives a view into some of the above.
And the diagnostic graphs produced in the model give more. 

Multicollinearity was handled already earlier when we chose only one variable out of
a set which was highly correlated with each other.

```{r}

p_pairs <- ggpairs(
  ds_subset_50_ave %>% 
    select(-cntry_name, -ess_year),
  lower = list(
    continuous = wrap("points", alpha = 0.3,    size=0.1)
    ),
  upper = list(
    continuous = wrap("cor", size = 1.5, alignPercent = 1)
  )) +
  theme(strip.text.x = element_text(size = 5),
        strip.text.y = element_text(size = 4),
        panel.grid.major = element_blank(), 
        axis.text = element_text(size = 2.5))

print(p_pairs)

the_correlations <- rcorr(as.matrix(ds_subset_50_ave %>% 
    select(-cntry_name, -ess_year)))

diag(the_correlations$r) <- NA
print(paste("Highest correlation coefficient", round(max(abs(the_correlations$r), na.rm = TRUE),3)))

# save space and compress correlation and p into the same matrix
CreateCorrPvalMatrix <- function(the_correlations) {
  the_correlations$r * lower.tri(the_correlations$r) +
    the_correlations$P * upper.tri(the_correlations$P)
}

knitr::kable(CreateCorrPvalMatrix(the_correlations),
             digits = 3, 
             caption = "Lower triangle: Correlation coefficients, upper triangle: p-values")

```

### The model

Basically, we start with a linear model with all variables and 
let 2-way stepAIC in MASS library to make the selection of the final variables.

```{r, warning=FALSE}

library(ggfortify)

MakeModel <- function(indata, response_var) {
  # create the model
  ds <- na.omit(indata)
  n_filtered <- nrow(indata) - nrow(ds)
  print(paste0("Linear modeling with 2-way stepAIC: Using ", nrow(ds), 
               ", removed ", n_filtered, " rows with NA"))
  # country name and year used as rownames to get informative model diagnostics text
  rownames(ds) <- paste(ds$cntry_name, ds$ess_year)
  ds <- ds %>% select(-cntry_name, -ess_year)
  # use 'response_var' as the name of the predicted / dependent variable internally
  # in the model
  colnames(ds)[colnames(ds)==response_var] <- "response_var"
  # initial model and refinement with stepAIC
  mymodel <- lm(formula = response_var~., data=ds)
  mymodel_final <- MASS::stepAIC(mymodel, direction = "both", trace = 0)
  return(mymodel_final)
}

PredictWithModel <- function(ds, mod, response_var, pred_level=0.95){
  # make prediction
  colnames(ds)[colnames(ds)==response_var] <- "response_var"
  y_pred <- predict(mod, newdata=ds, interval="predict",level = pred_level)
  return(list("y_pred"=y_pred[,1], "pred_int"=y_pred[,c(2,3)]))
}

CheckModel <- function(labels, ds, pred_val, response_var, k, txt_head=""){
  # show performance of the model
  colnames(ds)[colnames(ds)==response_var] <- "response_var"
  rsq <- r_squared(ds$response_var, pred_val$y_pred)
  rsqa <- r_squared_a(ds$response_var, pred_val$y_pred, k)
  
  # https://stackoverflow.com/questions/39811656/r-calculate-test-mse-given-a-trained-model-from-a-training-set-and-a-test-set
  MSPE <- mean((ds$response_var - pred_val$y_pred) ^ 2)
  
  print(paste0("For ", response_var))
  print(paste0("Mean squared prediction error: ", round(MSPE, 3)))
  print(paste0("                    R-squared: ", round(rsq, 3)))
  print(paste0("           Adjusted R-squared: ", round(rsqa, 3)))

  ds_result <- data.frame(country = labels,
                          true = ds$response_var,
                          predict = pred_val$y_pred,
                          lower = pred_val$pred_int[,1],
                          upper = pred_val$pred_int[,2])
  
  knitr::kable(ds_result,
               caption = paste("True and predicted", response_var, 
                               "with 95% prediction intervals"),
               digits = 3)

  # visualize the same  
  p <- ggplot(data=ds_result, aes(x=reorder(country,predict))) +
    geom_point(aes(y=predict), color="blue") +
    geom_errorbar(aes(ymin=lower, ymax=upper), color="blue", width=0.5) + 
    geom_point(aes(y=true), color="red", shape=4, size=3) +
    labs(title=paste(response_var, txt_head),
         subtitle="True scores (red), predicted with 95% prediction interval (blue) ") +
    xlab("") + ylab("") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          plot.title = element_text(hjust = 0),
          plot.subtitle = element_text(hjust = 0))
  print(p)
}

GetModelCoeffs <- function(the_mod, pred_name){
  txt_title <- paste(pred_name, "linear model coefficients")
  txt_subtitle  <- "Coefficients shown in descending order of absolute value"
  the_set <- summary(the_mod)$coefficients[-1,]
  df_set <- data.frame(variable = rownames(the_set),
                       coefficient = the_set[,1],
                       std_err = the_set[,2],
                       t_val = the_set[,3],
                       p_val = the_set[,4])
  p <- ggplot(data = df_set, 
              aes(x=reorder(variable, -abs(coefficient)), 
                  y=coefficient, fill=p_val)) +
    geom_bar(stat = "identity") +
    xlab("") + ylab("") +
    labs(title=txt_title,
         subtitle=txt_title) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5))
  return(list("plot"=p, "df"=df_set, "title"= txt_title, "subtitle"=txt_subtitle))
}


# 
GetModelCrossCorr <- function(ds, predict_this, factor_names) {
  p_pairs <- ggpairs(
    ds %>% 
      select(c(predict_this, as.character(factor_names))),
    lower = list(
      continuous = wrap("points", alpha = 0.3,    size=0.1)
    ),
    upper = list(
      continuous = wrap("cor", size = 1.5, alignPercent = 1)
    )) +
    theme(strip.text.x = element_text(size = 5),
          strip.text.y = element_text(size = 4),
          panel.grid.major = element_blank(), 
          axis.text = element_text(size = 2.5))
  return(p_pairs)
}

PredAndCheck <- function(predict_this, ds_train, ds_test, txt_head){
  # wrap the whole creating, predicting and illustrating into one function 
  print(paste("Predicted indicator =", predict_this))
  mod <- MakeModel(ds_train, predict_this)
  print(summary(mod))
  p <- autoplot(mod, label.size=3) + 
    labs(subtitle = predict_this)
  print(p)
  pred <- PredictWithModel(ds_test, mod, predict_this)
  CheckModel(ds_test$cntry_name, ds_test, pred, predict_this, mod$rank, txt_head)
  mod_coeffs <- GetModelCoeffs(mod, predict_this)
  pair_cc <- GetModelCrossCorr(
    ds = ds_train,
    predict_this = predict_this,
    factor_names = mod_coeffs$df$variable)
  
  return(list("model"=mod, "coeffs"=mod_coeffs, "paircc"=pair_cc))
}

ShowCoeffSummary <- function(coeffs, indicator_table) {
  print(coeffs$plot)
  knitr::kable(coeffs$df %>% 
                 arrange(desc(abs(coefficient))) %>% 
                 mutate(name = lapply(variable, 
                                      function(x) GetIndicator(as.character(x),
                                                               indicator_table)$name)), 
               row.names = FALSE, 
               caption = paste0(coeffs$title, "\n", coeffs$subtitle),
               digits = 3)
}

```

### Scale the data

This makes interpreting the results easier since the variables have different numeric ranges, e.g. impcntrl is from 1 to 4 and trstep between zero and 10.

In all fairness this is not a big deal as the scale used by ESS is somewhat arbitrary 
to begin with.

We use the countries which were in 50% or more of the surveys.

```{r}

ds_subset_50_ave_s <- ds_subset_50_ave %>%
  gather(indicator, value, setdiff(colnames(ds_subset_50_ave), metadata_columns)) %>%
  filter(!is.na(value)) %>%
  group_by(indicator) %>% 
  mutate(scaled_ave = scale(value)) %>%
  select(-value) %>%
  spread(indicator, scaled_ave) %>%
  ungroup()

summary(ds_subset_50_ave_s)

test_year <- 2016

```

### Training and testing data

We reserve the scores from `r test_year` for testing the model.
All other data used for training.

And for testing only the countries with non imputed data for that year are used.

```{r}

ds_train <- ds_subset_50_ave_s  %>% filter(ess_year < test_year)
dim(ds_train)

# Test data - only use data we really have, not imputed stuff
test_countries <- ds_participations %>% 
  filter(last_year==test_year) %>% 
  select(cntry_name)
ds_test  <- ds_subset_50_ave_s %>% 
  filter(ess_year == test_year, 
         cntry_name %in% test_countries$cntry_name)
print(paste("Countries used as test data in",
            test_year,
            ":",
            paste0(unique(ds_test$cntry_name), collapse=", ")))

```

## Models and observations

### Subjective Happiness

Investigating how the selected ESS variables are correlating with subjective happiness.

```{r, warning=FALSE}

the_mod <- PredAndCheck("happy", ds_train, ds_test, "- train 2002-2014, test 2016")

ShowCoeffSummary(the_mod$coeffs, indicator_table)

print(the_mod$paircc)

the_mod_sum <- summary(the_mod$model)

```

```{r}


```

The model explains `r round(100*the_mod_sum$adj.r.squared,1)`% of variation.

Note that for `impcntr` _Allow many/few immigrants from poorer countries outside Europe_ 
lower values of this indicator mean allowing more more immigration and higher values less.
Favoring more immigration is associated with higher happiness and 
"closing the borders" associated with lower level of happiness

### Helpful People 

#### ESS results

```{r, warning=FALSE}
ess_set <- GetObservationsSet(
  ds = ds_ss_avg,
  ds_obs = ds_subset_50,
  the_indicator = "pplhlp",
  indicator_table = indicator_table,
  cntry_list = cntry_in_100pct)

print(ess_set$summary)
MyPrintInteractive(ess_set$map, plot_wo_widget) 
MyPrintInteractive(ess_set$heat, plot_wo_widget) 
MyPrintInteractive(ess_set$sig$plot, plot_wo_widget) 
tab.3_cap <- table_nums(name="tab_3",
                        caption = paste0(ess_set$indicator$name, "2002-2016, significance and effect size of the change"))
```
`r table_nums("tab_3")`
```{r table3, fig.cap=tab.3_cap}
knitr::kable(ess_set$sig$table, digits = 3, 
             col.names = gsub("_", " ", colnames(ess_set$sig$table)))

```

#### Modeling

Investigating the highest factor in happy model - and excluding `happy` from the model as
I do not think it can be an independent variable at all.

```{r, warning=FALSE}

the_mod <- PredAndCheck("pplhlp", 
                        ds_train %>% select(-happy), 
                        ds_test%>% select(-happy), 
                        "- train 2002-2014, test 2016")
ShowCoeffSummary(the_mod$coeffs, indicator_table)
print(the_mod$paircc)
the_mod_sum <- summary(the_mod$model)

```

The model explains `r round(100*the_mod_sum$adj.r.squared,1)`% of variation.

Looks like here `happy` and `trstun` are major positive factors. 
`trstun` was seen as a major factor in `happy` as well.
The third biggest positive factor 
is  `imwbcnt` _Immigrants make country worse or better place to live_.

Interestingly, this is negatively correlated with the `euftf` _European Union: European unification go further or gone too far_.
And there is a negative correlation with `imueclt` _Country's cultural life undermined or enriched by immigrants_.

### Trust in United Nations

Trust in the UN seems to be an important factor, so let's drill deeper.

#### ESS results

```{r, warning=FALSE}
ess_set <- GetObservationsSet(
  ds = ds_ss_avg,
  ds_obs = ds_subset_50,
  the_indicator = "trstun",
  indicator_table = indicator_table,
  cntry_list = cntry_in_100pct)

print(ess_set$summary)
MyPrintInteractive(ess_set$map, plot_wo_widget) 
MyPrintInteractive(ess_set$heat, plot_wo_widget) 
MyPrintInteractive(ess_set$sig$plot, plot_wo_widget) 
tab.4_cap <- table_nums(name="tab_4",
                        caption = paste0(ess_set$indicator$name, "2002-2016, significance and effect size of the change"))
```
`r table_nums("tab_4")`
```{r table4, fig.cap=tab.4_cap}
knitr::kable(ess_set$sig$table, digits = 3, 
             col.names = gsub("_", " ", colnames(ess_set$sig$table)))

```

#### Modeling

```{r}
the_mod <- PredAndCheck("trstun", 
                        ds_train %>% select(-happy), 
                        ds_test%>% select(-happy), 
                        "- train 2002-2014, test 2016")
ShowCoeffSummary(the_mod$coeffs, indicator_table)
print(the_mod$paircc)
the_mod_sum <- summary(the_mod$model)

```

The model explains `r round(100*the_mod_sum$adj.r.squared,1)`% of variation.

### Trust in European Parliament

#### EES Results

```{r, warning=FALSE}

ess_set <- GetObservationsSet(
  ds = ds_ss_avg,
  ds_obs = ds_subset_50,
  the_indicator = "trstep",
  indicator_table = indicator_table,
  cntry_list = cntry_in_100pct)

print(ess_set$summary)
MyPrintInteractive(ess_set$map, plot_wo_widget) 
MyPrintInteractive(ess_set$heat, plot_wo_widget) 
MyPrintInteractive(ess_set$sig$plot, plot_wo_widget) 
tab.5_cap <- table_nums(name="tab_5",
                        caption = paste0(ess_set$indicator$name, "2002-2016, significance and effect size of the change"))
```
`r table_nums("tab_5")`
```{r table5, fig.cap=tab.5_cap}
knitr::kable(ess_set$sig$table, digits = 3, 
             col.names = gsub("_", " ", colnames(ess_set$sig$table)))

```

As can be seen above, the big positive changes in UK and Portugal as well as 
Finland and Slovenia from 2014 to
2016 were significant as per weighted t-test.

And the same applies to quite large drops in Belgium, France and Hungary.

With more investigation one might find some interesting correlations between those changes 
and other indicators in ESS data and elsewhere.
But that adventure is beyond the scope of this post.

#### Modeling


```{r}

the_mod <- PredAndCheck("trstep", 
                        ds_train %>% select(-happy), 
                        ds_test%>% select(-happy), 
                        "- train 2002-2014, test 2016")
ShowCoeffSummary(the_mod$coeffs, indicator_table)
print(the_mod$paircc)
the_mod_sum <- summary(the_mod$model)

```

The model explains `r round(100*the_mod_sum$adj.r.squared,1)`% of variation.

### Immigrants from poorer countries outside Europe

#### EES Results

```{r, warning=FALSE}

ess_set <- GetObservationsSet(
  ds = ds_ss_avg,
  ds_obs = ds_subset_50,
  the_indicator = "impcntr",
  indicator_table = indicator_table,
  cntry_list = cntry_in_100pct)

print(ess_set$summary)
MyPrintInteractive(ess_set$map, plot_wo_widget) 
MyPrintInteractive(ess_set$heat, plot_wo_widget) 
MyPrintInteractive(ess_set$sig$plot, plot_wo_widget) 
tab.6_cap <- table_nums(name="tab_6",
                        caption = paste0(ess_set$indicator$name, "2002-2016, significance and effect size of the change"))
```
`r table_nums("tab_6")`
```{r table6, fig.cap=tab.6_cap}
knitr::kable(ess_set$sig$table, digits = 3, 
             col.names = gsub("_", " ", colnames(ess_set$sig$table)))

```

#### Modeling

```{r, warning=FALSE}

the_mod <- PredAndCheck("impcntr", 
                        ds_train %>% select(-happy), 
                        ds_test%>% select(-happy), 
                        "- train 2002-2014, test 2016")
ShowCoeffSummary(the_mod$coeffs, indicator_table)
print(the_mod$paircc)
the_mod_sum <- summary(the_mod$model)

```

The model explains `r round(100*the_mod_sum$adj.r.squared,1)`% of variation.


## Clustering the countries

We investigate if there are any clusters of countries in the data using as clusterig elements
observations identified by country name and year of ess survey where all selected ess indicators

### Preprocess

```{r}

# create subset with ESS indicators only
drop_cols <- which(colnames(ds_ss_avg_cntry_ind) %in% c((indicator_table %>% 
  filter(source %in% c("WB", "UNHCR")))$indicator))
mydata <- ds_ss_avg_cntry_ind[,-drop_cols]
dim(mydata)
summary(mydata)

# remove records with NAs
myDataClean = na.omit(mydata)
dim(myDataClean)
summary(myDataClean)

#remove metadata fields and scale the rest
scaled_data = as.matrix(scale(myDataClean[,-which(colnames(myDataClean) %in% metadata_columns)]))
rownames(scaled_data) <- paste(myDataClean$cntry_name, myDataClean$ess_year)

```

### PCA

Experiment reducing dimensionality with Primary Component Analysis

```{r}

# PCA
pc <- prcomp(scaled_data)
PoV <- pc$sdev^2/sum(pc$sdev^2) # proportion of variance
CumPoV <- cumsum(PoV)
n_CumPoV_085 <- length(which(CumPoV <=0.85))
print(paste(n_CumPoV_085, "principal components explain 85% of variance"))
p_var <- ggplot(data=data.frame(PoV=PoV, CumPoV=CumPoV, n=1:length(CumPoV)), aes(x=n)) +
  geom_bar(aes(y=PoV), fill="red", stat="identity") +
  geom_line(aes(y=CumPoV), color="black") +
  geom_hline(yintercept = 0.85, linetype="dashed") +
  geom_vline(xintercept = n_CumPoV_085, linetype="dashed") +
  labs(title="Principal Componen Analysis - Proportion of Variance",
       subtitle="Individual and cumulative variance explained (using 'prcomp')") + 
  xlab("Principal Component")

MyPrintInteractive(p_var, plot_wo_widget) 

knitr::kable(pc$rotation, digits = 2, caption = "Primary componets vs indicators")

# plot two first PCs
library(ggfortify)
# autoplot(pc)

# Take the principal components needed for 85%
comp <- data.frame(pc$x[,1:n_CumPoV_085])

# Plot cross correlations
ggpairs(data=comp) +
  labs(title="Correlations between Primary Components",
       subtitle="Zero correlations - as expected")


```

### K-means clustering

Identifying potential clusters in country / ess year indicator rows using the PCA analysis results.

```{r}

# Use the data in PCA space for k-means clustering

kmeans_data <- comp

# fix randomization
set.seed(123)

# find clusters, set max value to be count of countries in the dataset
k.max <- length(unique(myDataClean$cntry_name))
print(paste("Set upper bound to clusters the count of countries in the dataset", k.max))

# Elbow Method for visually finding the optimal number of clusters
wss <- sapply(1:k.max, 
              function(k){
                kmeans(kmeans_data, k, nstart=50,iter.max = 15)$tot.withinss
              })
ggplot(data = data.frame(n=1:k.max, wss=wss), aes(x=n, y=wss)) +
  geom_line() +
  geom_point() +
  labs(title="Elbow method",
       substitle="Visually identify an 'elbow' in the plot") +
  xlab("Number of clusters K") +
  ylab("Total within-clusters sum of squares")

# NbClust - vote on kmeans ==> use this as the outcome
library(NbClust)
nb <- NbClust(kmeans_data, 
              diss=NULL, 
              distance = "euclidean", 
              min.nc=2, 
              max.nc=k.max, 
              method = "kmeans", 
              index = "all", 
              alphaBeale = 0.1)

print(sort((nb$Best.nc[1,])))

ggplot(data=data.frame(n=nb$Best.nc[1,]), aes(n)) +
  geom_histogram(binwidth = 1) +
  labs(title="cluster count using several methods",
       subtitle="As majority vote determined by 'NbClust' function")

n_clusters <- length(unique(nb$Best.partition))
print(paste("Majority vote decision:", n_clusters, "clusters"))

```

Visual identification is always somewhat vague. 
Fortunately there is an algorithm that can do it independently - even if one can
always havwe a debate on whether the selection the algorithm made was right.
This looks good enough for this purpose - at least for now.

### Visualize groups in PCA space

Annoyingly, the two plots do not use the same colours for clusters. 

```{r}
# wrap results into a dataset
ds_clusters <- data.frame(cluster = as.factor(nb$Best.partition),
                          cntry_name = myDataClean$cntry_name,
                          ess_year = myDataClean$ess_year) 

# show in PCA space

library(cluster)
pam_obj <- pam(scaled_data, n_clusters)
autoplot(pam_obj, frame.type = 'norm', label=TRUE, label.size=2.5, label.alpha=0.6) +
  labs(title="Countries classified by ESS survey",
       subtitle="Each classification identified")

autoplot(prcomp(scaled_data), data=ds_clusters, colour='cluster', 
         loadings = TRUE, loadings.colour = 'blue',
         loadings.label = TRUE, 
         loadings.label.size = 3) +
  labs(title="Countries classified by ESS survey",
       subtitle="Eigenvectors of original indicators shown")

```

### Countries split to classes

The Nordic countries are in the same cluster, which is not that surprising
given their relatively common values and ways in their respective societies.
Other participants in that cluster are perhaps not as clear or 
obvious - at least to me.

And then there is the rest of Europe in the other cluster.

(I did at some point of time the same clustering excercise using scaled indicators 
and came up with the same clusters as with PCA)

```{r, warning=FALSE}

# classify countries based on the clusters they have most often been based on survey scores

cntry_clusters <- ds_clusters %>% 
  group_by(cntry_name, cluster) %>% 
  summarise(n=n()) %>% 
  arrange(desc(n)) %>%
  filter(!duplicated(cntry_name)) %>%
  arrange(cluster)

p <- CreateEuroMap(dsin = cntry_clusters %>% ungroup(), 
                   ind_name = "cluster",
                   txt_title = "Countries clustered by indicators",
                   txt_subtitle = "Based on the cluster a country most often has been in",
                   txt_caption = "ESS surveys 2002-2016")
MyPrintInteractive(p, plot_wo_widget) 

# how does clustering changed annually

clustered_years <- ds_clusters %>% 
  group_by(ess_year, cluster) %>% 
  summarise(n=n())

p <- ggplot(data = clustered_years, aes(x=ess_year, y=n, fill=cluster)) +
  geom_bar_interactive(stat = "identity", 
                       position = "fill",
                       aes(tooltip=paste0(ess_year, ' - cluster ', cluster, '\nn=', n))) +
  geom_hline(yintercept = c(0.25, 0.5, 0.75), linetype="dashed") + 
  labs(title="Relative size of groups",
       subtitle = "As classified by country/survey granularity",
       txt_caption = "ESS surveys 2002-2016") +
  xlab("") + ylab("")
MyPrintInteractive(p, plot_wo_widget) 

```

Looking into details of how do the two grups differ we can see that in most of 
the indicators countries in cluster 2 give higher scores which 
roughly translate to “more” or “better” — with a couple of noteworthy exceptions

* health – low value is good and high value is poor health
* impcntrl – low value means more immigration and high less immigration from poor countriesThere seems 

```{r, warning=FALSE}

# compare the indicators between classes

p <- ggplot(data=ds_ss_avg %>% 
              filter(indicator %in% (indicator_table %>% filter(source=="ESS"))$indicator) %>%
              group_by(indicator) %>%
              mutate(value_s = scale(value)) %>%
              ungroup() %>%
              left_join(cntry_clusters %>%  
                          select(cntry_name, cluster), 
                        by="cntry_name"),
            aes(x=indicator, y=value_s, fill=cluster)) +
  geom_boxplot_interactive(aes(tooltip = paste(indicator,'\nclust ', cluster))) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5)) +
  xlab("") + ylab("") +
  labs(title="Differences between groups of countries",
       subtitle="Variables scaled to same range")
MyPrintInteractive(p, plot_wo_widget) 

```

Using the same classification on selected World Bank and UNHCR seems to be supportive
of the grouping even though no formal clustering based on these values has been 
conducted - at least not yet.

```{r, warning=FALSE}
# World Bank
p <- ggplot(data=ds_ss_avg %>% 
         filter(indicator %in% (indicator_table %>%
                                  filter(indicator %in% pct_indicators,
                                         source=="WB"))$indicator) %>%
         left_join(cntry_clusters %>%  
                     select(cntry_name, cluster), 
                   by="cntry_name"),
       aes(x=indicator, y=value, fill=cluster)) +
  geom_boxplot_interactive(aes(tooltip = paste(indicator,'\nclust ', cluster))) + 
  # geom_boxplot_interactive() + 
  xlab("") + ylab("") +
  labs(title="Differences between groups of countries",
       subtitle="WB Variables", 
       caption = "World Bank") +
  coord_flip()
MyPrintInteractive(p, plot_wo_widget) 


# UNHCR
p <- ggplot(data=ds_ss_avg %>% 
         filter(indicator %in% (indicator_table %>% 
                                  filter(indicator %in% pct_indicators,
                                         source=="UNHCR"))$indicator,
                !is.na(value)) %>%
         left_join(cntry_clusters %>%  
                     select(cntry_name, cluster), 
                   by="cntry_name"),
       aes(x=indicator, y=value+1, fill=cluster)) +
  geom_boxplot_interactive(aes(tooltip = paste(indicator,'\nclust ', cluster))) + 
#  geom_boxplot_interactive() + 
  scale_y_log10() +
  xlab("") + ylab("") +
  labs(title="Differences between groups of countries",
       subtitle="UNHCR Variables on logarithmic scale (offset +1%)",
       caption="UNHCR") +
  coord_flip()
MyPrintInteractive(p, plot_wo_widget) 

```

Visual box plot comparisons of selected UNHCR and WB indicators seem to support the clustering
clustering based on ESS data.

* Cluster 2 countries appear more urbanized than cluster 1
* Proportion of population born in another country is higher in cluster 2 even though there is quite some overlap in distributions
* There is higher percentage of people active in workforce in cluster 2
* Government health and education expenditures vs. GDP are higher in cluster 2
* GDP growth (and per capita growth) is higher in cluster 1 countries but there is significant overlap with cluster 2 distribution
* Significantly higher share of population is using Internet in cluster 2 compared to cluster 1
* Tax revenues as % of GDP are higher in cluster 2
* Personal remittances received (% of GDP) is higher in cluster 1

## Summary

ESS data is an interesting source for getting insights into the recent history and ongoing present of Europe from data.

In this post perhaps the most interesting – but perhaps not surprising – findings were

* Europe can be split into two groups of countries, apparently with different views on life in general and on immigration and refugees
* major explaining factors for subjective happiness were willingness of people to help other (positive, not surprising) and trust in United Nations (negative, somewhat strange, indirectly linked to trust in European Parliament as it is the main positive factor in trust in United Nations)
* major explaining factors for trust in European Parliament were trust in United Nations (positive), satisfaction in government (positive), further integration of European Union (positive), which all were perhaps not surprising
* views on immigration and refugees are polarized and it appears that those countries where immigration is seen positively impacting economy tend to be those which are more open to immigration from poor countries outside of Europe

Linking between ESS and other data may give further insights and I will probably return to this topic later.


```{r}


```


* * *

## References

A real serious study on the topic (I've yet to read myself):

* Europeans’ Personal and Social Wellbeing, Topline Results from Round 6 of the
European Social Survey
* link: http://www.europeansocialsurvey.org/docs/findings/ESS6_toplines_issue_5_personal_and_social_wellbeing.pdf

### ESS

Citation of data: 

* European Social Survey Cumulative File, ESS 1-7 (2016). Data file edition 1.0. NSD - Norwegian Centre for Research Data, Norway - Data Archive and distributor of ESS data for ESS REIC.
* European Social Survey Round 8 Data (2016). Data file edition 2.0. NSD - Norwegian Centre for Research Data, Norway - Data Archive and distributor of ESS data for ESS ERIC 

Citation of documentation: 

* European Social Survey (2016). ESS 1-7, European Social Survey Cumulative File, Study Description. Bergen: NSD - Norwegian Centre for Research Data for ESS ERIC.
* European Social Survey (2016): ESS8- 2016 Documentation Report. Edition 2.0. Bergen, European Social Survey Data Archive, NSD - Norwegian Centre for Research Data for ESS ERIC 

Distributor of Data

 NSD - Norwegian Centre for Research Data,   
 Harald Hårfagresgt. 29 N-5007 Bergen, Norway.    
 Phone: +47 55 58 21 17    
 Fax: +47 44 58 96 50   
 e-mail: nsd@nsd.no    
 Web: http://www.nsd.no/english    

 ESS: essdata@nsd.no   
 ESS: www.europeansocialsurvey.org   

### World Bank

World Development Indicators https://data.worldbank.org/products/wdi

The primary World Bank collection of development indicators, compiled from officially-recognized international sources. It presents the most current and accurate global development data available, and includes national, regional and global estimates.

Excel file was downloaded and used

### UNHCR

Population Statistics / Time Series http://popstats.unhcr.org/en/time_series

On this page, each row of data represents the information about UNHCR’s populations of concern for a given year and country of residence and/or origin. Data is presented as a yearly time series across the page. In the 2017 data, figures between 1 and 4 have been replaced with an asterisk (*). These represent situations where the figures are being kept confidential to protect the anonymity of individuals. Such figures are not included in any totals”

Csv extract of all data was used.

## Technical notes

Caption and figure numbering is produced as described by Norbert Köhler in 
his blog post ["R Markdown: How to number and reference tables"](https://datascienceplus.com/r-markdown-how-to-number-and-reference-tables/)

Top matter definitions

* Azure - handles javascript, no problem with document size
    * output:
        * html_document:
            * toc: yes
            * toc_depth: 4
    * params:
        * html_wo_widget: TRUE
        * explore_indicator_graphs: TRUE
        * explore_country_graphs: TRUE
        
* RPubs - handles javascript, document size limitation
    * output:
        * html_document:
            * toc: yes
            * toc_depth: 4
    * params:
        * html_wo_widget: TRUE
        * explore_indicator_graphs: FALSE
        * explore_country_graphs: FALSE
        
* Github - does not handle javascript, no size limit
    * output:
        * github_document:
            * toc: yes
            * toc_depth: 4
    * params:
        * html_wo_widget: FALSE
        * explore_indicator_graphs: TRUE
        * explore_country_graphs: TRUE
