#
# Functions used in ESS analysis
#

# Helpers

MyPrintInteractive <- function(p, make_interactive, hover_css = "") {
  # github_markup generation does not like javascript generated by ggiraph, 
  # therefore having a switch to disable it when needed
  # it works mostly in R-Studio and when generating html 
  # (but not from inside loops)
  if (make_interactive) {
    if (hover_css == "")
      ggiraph(code = {print(p)})
    else
      ggiraph(code = {print(p)}, hover_css = hover_css)
  }  else
    print(p)
}


# ESS Data

GetData <- function(data_folder, use_rds) {
  if (!use_rds) {
    # merge a subset from surveys 1-7 (excluded most country specific indicators at download phase)
    # and full set from survey 8 into one common set - survey 8 was not yet available in the
    # same wizard as earlier ones
    essfile_0107 <- paste0(data_folder, "ESS\\ESS1-7e01.csv")
    essdata_0107 <- read.csv(essfile_0107)
    essfile_08 <- paste0(data_folder, "ESS\\ESS8e02.0_F1.csv")
    essdata_08 <- read.csv(essfile_08)
    common_indicators <-
      intersect(colnames(essdata_08), colnames(essdata_0107))
    dataset <-
      rbind(essdata_0107[, common_indicators], essdata_08[, common_indicators])
    # for convenience, turning the survey ids into years when conducted
    dataset$ess_year <- 2000 + 2 * dataset$essround
    # english country names
    dataset$cntry_name <-
      countrycode(dataset$cntry, "iso2c", "country.name")
    # save for faster iteration later on
    saveRDS(dataset, paste0(data_folder, "ESS\\ess.rds"))
    rm(essdata_0107, essdata_08)
  } else {
    dataset <- readRDS(paste0(data_folder, "ESS\\ess.rds"))
  }
  return(dataset)
}

# Get dates of joining EU
GetEuDates <- function() {
  
  
}

# WB Data

FixCountry <- function(ds, from, to) {
  idx <- which(ds$`Country Name` == from)
  ds$`Country Name`[idx] <- to
  return(ds)
}


GetWbData <- function(data_folder, read_rds, inc_countries, min_year, max_year, print_diagnostic = FALSE) {
  
  rds_filename <- "wbdevforess.rds"
  
  if (!read_rds)  {
    library(readxl)
    
    WDIEXCEL <- read_excel(paste0(data_folder, "WDIEXCEL.xlsx"))
    
    if (print_diagnostic) print(dim(WDIEXCEL))
    
    inc_indicators <- c(
      'BX.TRF.PWKR.DT.GD.ZS',
      #	Economic Policy & Debt: Balance of payments: Current account: 
      #	Transfers	Personal remittances, received (% of GDP)
      'GC.TAX.TOTL.GD.ZS',
      # Public Sector: Government finance: 
      # Revenue	Tax revenue (% of GDP)
      'IT.NET.USER.ZS',
      # Infrastructure: Communications	
      # Individuals using the Internet (% of population)
      'NY.GDP.MKTP.KD',
      # Economic Policy & Debt: National accounts: 
      # US$ at constant 2010 prices: Aggregate indicators	
      # GDP (constant 2010 US$)
      'NY.GDP.MKTP.KD.ZG',
      # Economic Policy & Debt: National accounts: Growth rates	
      # GDP growth (annual %)
      'NY.GDP.PCAP.KD',
      # Economic Policy & Debt: National accounts: US$ at constant 2010 prices: 
      # Aggregate indicators	
      # GDP per capita (constant 2010 US$)
      'NY.GDP.PCAP.KD.ZG',
      # Economic Policy & Debt: National accounts: 
      # Growth rates	GDP per capita growth (annual %)
      'SE.XPD.TOTL.GD.ZS',
      # Education: Inputs	
      # Government expenditure on education, total (% of GDP)
      'SH.XPD.GHED.GD.ZS',
      # Health: Health systems	
      # Domestic general government health expenditure (% of GDP)
      'SL.TLF.CACT.ZS',
      # Social Protection & Labor: Labor force structure	
      # Labor force participation rate, total (% of total population ages 15+) (modeled ILO estimate)
      'SM.POP.TOTL.ZS',
      # Social Protection & Labor: Migration	
      # International migrant stock (% of population)	
      # International migrant stock is the number of people born 
      # in a country other than that in which they live, including refugees.
      'SP.POP.TOTL',
      # Health: Population: Structure	Population, total
      'SP.RUR.TOTL.ZS',
      # Environment: Density & urbanization	
      # Rural population (% of total population)
      'SP.URB.TOTL.IN.ZS',
      #	Environment: Density & urbanization	
      #	Urban population (% of total)
      'SM.POP.REFG'           
      # Social Protection & Labor: Migration	
      # Refugee population by country or territory of asylum
    )
    
    ds_wdi <- WDIEXCEL %>%
      filter(`Indicator Code` %in% inc_indicators)
    
    ds_wdi <- FixCountry(ds_wdi, "Slovak Republic", "Slovakia")
    ds_wdi <- FixCountry(ds_wdi, "Russian Federation", "Russia")
    ds_wdi <- FixCountry(ds_wdi, "Czech Republic", "Czechia")
    
    ds_wdi <- ds_wdi %>%
      filter(`Country Name` %in% inc_countries)
    
    if (!identical(sort(unique(ds_wdi$`Country Name`)), sort(inc_countries)))
      stop("country names mismatch")
    
    # column names are years..  taking years starting from the minimum
    col_names <- colnames(ds_wdi)
    if (print_diagnostic) print(col_names)
    year_set = seq(from=min_year, to=max_year)
    ds_wdi <- ds_wdi[, col_names[c(1:4, which(col_names %in% year_set))]]
    print("Wide format, years in question")
    print(summary(ds_wdi))
    
    # wide to narrow
    new_df <- ds_wdi %>%
      gather(year, value, which(colnames(ds_wdi) %in% year_set))
    new_df$year <- as.numeric(new_df$year)
    
    # fill missing
    new_df <- new_df %>%
      group_by(`Country Name`, `Indicator Code`) %>%
      mutate(value = zoo::na.fill(value, "extend")) %>%
      ungroup()
    
    # fix colunm names
    new_df <- new_df %>%
      mutate(
        cntry_name = `Country Name`,
        name  = `Indicator Name`,
        indicator = `Indicator Code`,
        ess_year = year,
        source = "WB"
      ) %>%
      select(cntry_name, ess_year, indicator, name, value, source)
    
    saveRDS(new_df, rds_filename)
    
  } else {
    new_df <- readRDS(rds_filename)
  }
  
  return(new_df)
}


GetPreProcessWbData <- function(data_folder, read_rds, inc_countries, min_year, max_year ) {
  
  wb_data <- GetWbData(data_folder, read_rds, inc_countries , min_year, max_year)
  
  # calculate refugees by population
  ref_pop <- wb_data %>%
    select(-name, -source) %>%
    filter(indicator %in% c('SM.POP.REFG', 'SP.POP.TOTL')) %>%
    spread(indicator, value) %>%
    mutate(
      value = SM.POP.REFG / SP.POP.TOTL * 100,
      indicator = 'REFG.PCT',
      source="WB",
      name = 'Refugees (% of population) - calculated'
    ) %>%
    select(-SM.POP.REFG,-SP.POP.TOTL)
  
  wb_data <- wb_data %>%
    bind_rows(ref_pop)
  
  wb_ind <- wb_data %>% 
    group_by(indicator) %>%
    summarise(min = min(value, na.rm = TRUE),
              max = max(value, na.rm = TRUE)) %>% 
    left_join(wb_data %>% 
                select(indicator, name, source)) %>%
    filter(!duplicated(indicator)) %>% 
    select(indicator, name, min, max, source)
  
  return((list("data"=wb_data, "indicators"=wb_ind)))
}


GetUnhcrData <- function(data_folder, read_rds, inc_countries, min_year, max_year, print_diagnostic = FALSE) {
  rds_filename <- "unhcrforess.rds"
  
  if (!read_rds)  {
    filename_unhcr <- paste0(data_folder,"unhcr_popstats_export_time_series_all_data.csv")
    if (print_diagnostic) print(filename_unhcr)
    ds_asyl <-read.csv(filename_unhcr, skip = 3)
    if (print_diagnostic) print(dim(ds_asyl))
    ds_asyl <- ds_asyl %>%
      filter(Year >= min_year, Year <= max_year) %>%
      mutate(
        `Country Name` = as.character(Country...territory.of.asylum.residence),
        year = Year,
        pop_type = Population.type,
        Value_num = as.numeric(trimws(Value))
      ) %>%
      filter(!is.na(Value_num)) %>%
      group_by(`Country Name`, year, pop_type) %>%
      summarise(value = sum(Value_num)) %>%
      ungroup()
    if (print_diagnostic) print(dim(ds_asyl))
    
    ds_asyl <- FixCountry(ds_asyl, "Russian Federation", "Russia")
    ds_asyl <- FixCountry(ds_asyl, "Czech Rep.", "Czechia")
    
    ds_asyl <- ds_asyl %>%
      filter(`Country Name` %in% inc_countries)
    
    if (!identical(sort(unique(ds_asyl$`Country Name`)), sort(inc_countries)))
      stop("country names mismatch")
    
    ds_asyl$name <- 'Persons of concern'
    ds_asyl$indicator <- 'PERS.CONCERN'
    
    ds_asyl <- ds_asyl %>%
      mutate(cntry_name = `Country Name`,
             ess_year = year,
             source = "UNHCR") %>%
      select(cntry_name, ess_year, indicator, name, pop_type, value, source)
    
    saveRDS(ds_asyl, rds_filename)
  } else {
    ds_asyl <- readRDS(rds_filename)
  }
  
  return(ds_asyl)
}

GetPreProcessUnhcrData <- function(ds_unhcr, ds_wb, new_indicator, new_name ) {
  
  # calculate share of persons of concern vs population
  pers_concern <- ds_unhcr %>% 
    select(-source, -name) %>% 
    # WB data has populations
    bind_rows(ds_wb %>% 
                select(-source, -name) %>% 
                filter(indicator=="SP.POP.TOTL",
                       ess_year %in% unique(ds_unhcr$ess_year))) %>%
    spread(indicator, value) %>%
    # new calculated 
    mutate(value = PERS.CONCERN/SP.POP.TOTL*100,
           indicator = new_indicator, # 'PERS.CONCERN.PCT',
           source="UNHCR",
           name =  new_name #'Persons of concern (% of population) - calculated'
    ) %>%
    select(-PERS.CONCERN, -SP.POP.TOTL)
  
  # indicator set  
  unhcr_ind <- pers_concern %>% 
    group_by(indicator) %>%
    summarise(min = min(value, na.rm = TRUE),
              max = max(value, na.rm = TRUE)) %>% 
    left_join(pers_concern %>% 
                select(indicator, name, source),
              by="indicator") %>%
    filter(!duplicated(indicator)) %>% 
    select(indicator, name, min, max, source)
  
  return(list("data"=pers_concern, "indicators"=unhcr_ind))
}

#
# Maps
#

library(rgeos)
library(maptools)

SetupMyMap <- function(data_folder, ds_participations) {
  # using geographic data downloaded from http://www.naturalearthdata.com/downloads/10m-cultural-vectors/
  mymapdata <-
    paste0(data_folder,
           "NaturalEarthWorld\\ne_10m_admin_0_countries.shp")
  # when using readShapeSpatial getting notifications to change to some other function
  # todo later in some other project as it works still..
  mymap <- readShapeSpatial(mymapdata)
  
  # checking that all our countries can be found in map data
  idx <-
    which(!(ds_participations$cntry_name %in% mymap@data$ADMIN))
  if (length(idx) > 0)
    stop("Missing countries!!")
  
  # good - using country names from the column ADMIN
  mymap <- fortify(mymap, region = "ADMIN")
  
  # setting limits of interest in geography
  geo_limits_lat <- c(31, 71)
  geo_limits_lon <- c(-25, 45)
  
  # country outlines
  outline_layer <- geom_polygon(
    aes(long, lat, group = group),
    fill = NA,
    col = "gray",
    size = 0.1
  )
  
  return(
    list(
      "mymap" = mymap,
      "geo_limits_lat" = geo_limits_lat,
      "geo_limits_lon" = geo_limits_lon,
      "outline_layer" = outline_layer
    )
  )
}


# Europe choropleth map for an indicator 
CreateEuroMap <- function(mymap, ds, ind_name, txt_title, txt_subtitle, txt_caption){
  
  if (length(which(colnames(ds)=="cntry_name"))==0) stop("cntry_name missing, required")
  colnames(ds)[colnames(ds)==ind_name] <- "myplotind"
  
  use_discrete <- (class(ds$myplotind) == "factor")
  
  p <- ggplot(mymap$mymap) + 
    coord_quickmap() +
    geom_map(data = ds, 
             aes(map_id = cntry_name, fill = myplotind), 
             map = mymap$mymap) + 
    mymap$outline_layer + 
    expand_limits(x = mymap$long, y = mymap$lat) +
    xlim(mymap$geo_limits_lon) + 
    ylim(mymap$geo_limits_lat) + 
    scale_fill_viridis(discrete = use_discrete) +
    theme(axis.title=element_blank(),
          axis.text=element_blank(),
          axis.ticks=element_blank(),
          legend.title=element_blank(),
          plot.title = element_text(hjust = 0),
          plot.subtitle = element_text(hjust = 0)) +
    labs(title = txt_title,
         subtitle = txt_subtitle,
         caption = txt_caption)
  
  return(p)
}



#
# Heatmap
#


MakeAverageSummary <- function(ds, value_term) {
  colnames(ds)[colnames(ds) == value_term] <- "value_term"
  # add averages by country
  dsx1 <- ds %>%
    group_by(cntry_name) %>%
    summarise(value_term = mean(value_term, na.rm = TRUE)) %>%
    mutate(ess_year = "Mean") %>%
    bind_rows(ds %>%
                ungroup() %>%
                mutate(ess_year = as.character(ess_year)))
  # add averages by ess_year
  dsx <- dsx1 %>%
    group_by(ess_year) %>%
    summarise(value_term = mean(value_term, na.rm = TRUE)) %>%
    mutate(cntry_name = "Mean") %>%
    bind_rows(dsx1)
  # set countries into order
  cntry_list <- (dsx %>%
                   filter(ess_year == "Mean", cntry_name != "Mean") %>%
                   arrange(value_term))$cntry_name
  dsx$cntry_name <- factor(dsx$cntry_name, c("Mean", cntry_list))
  colnames(dsx)[colnames(dsx) == "value_term"] <- value_term
  return(dsx)
}

MakeIndicatorHeatSet <-
  function(dsx,
           value_term,
           txt_name,
           txt_subtitle,
           txt_caption) {
    colnames(dsx)[colnames(dsx) == value_term] <- "value_term"
    # get the plot
    p <- ggplot(dsx, aes(ess_year, cntry_name)) +
      geom_tile_interactive(aes(fill = value_term,
                                tooltip = paste(cntry_name,
                                                round(value_term, 1))), color = "white") +
      scale_fill_viridis() +
      geom_text(aes(label = round(value_term, 1)), size = 2) +
      ylab(" ") + xlab("") +
      theme(
        legend.title = element_blank(),
        legend.text = element_text(size = 8),
        plot.title = element_text(size = 16,
                                  hjust = 0),
        axis.title = element_text(size = 14, face = "bold"),
        axis.text = element_text(size = 7)
      ) +
      labs(
        fill = "Mean",
        title = txt_name,
        subtitle = txt_subtitle,
        caption = txt_caption
      )
    
    return(p)
  }

MakeIndicatorHeatSetOld <-
  function(ds,
           value_term,
           txt_name,
           txt_subtitle,
           txt_caption) {
    colnames(ds)[colnames(ds) == value_term] <- "value_term"
    # add averages by country
    dsx1 <- ds %>%
      group_by(cntry_name) %>%
      summarise(value_term = mean(value_term, na.rm = TRUE)) %>%
      mutate(ess_year = "Mean") %>%
      bind_rows(ds %>%
                  ungroup() %>%
                  mutate(ess_year = as.character(ess_year)))
    # add averages by ess_year
    dsx <- dsx1 %>%
      group_by(ess_year) %>%
      summarise(value_term = mean(value_term, na.rm = TRUE)) %>%
      mutate(cntry_name = "Mean") %>%
      bind_rows(dsx1)
    # set countries into order
    cntry_list <- (dsx %>%
                     filter(ess_year == "Mean", cntry_name != "Mean") %>%
                     arrange(value_term))$cntry_name
    dsx$cntry_name <- factor(dsx$cntry_name, c("Mean", cntry_list))
    # get the plot
    p <- ggplot(dsx, aes(ess_year, cntry_name)) +
      geom_tile_interactive(aes(fill = value_term,
                                tooltip = paste(cntry_name,
                                                round(value_term, 1))), color = "white") +
      scale_fill_viridis() +
      geom_text(aes(label = round(value_term, 1)), size = 2) +
      ylab(" ") +
      xlab("") +
      theme(
        legend.title = element_blank(),
        legend.text = element_text(size = 8),
        plot.title = element_text(size = 16,
                                  hjust = 0),
        axis.title = element_text(size = 14, face = "bold"),
        axis.text = element_text(size = 7)
      ) +
      labs(
        fill = "Mean",
        title = txt_name,
        subtitle = txt_subtitle,
        caption = txt_caption
      )
    # convert from function internal to external name
    colnames(dsx)[colnames(dsx) == "value_term"] <- value_term
    return(list("data" = dsx, "plot" = p))
  }

#
# Trends
#

MakeIndicatorCountryPlot <-
  function(ds,
           id_term,
           cntry_term,
           year_term,
           txt_head,
           txt_subhead,
           txt_caption,
           show_summary,
           label_size_coef = 1,
           plevel = 0.05) {
    colnames(ds)[colnames(ds) == id_term] <- "id_term"           # context of the plot
    colnames(ds)[colnames(ds) == cntry_term] <- "cntry_term"     # lines
    colnames(ds)[colnames(ds) == year_term] <- "year_term"       # x-axis
    
    # calculate simple overall mean, median and confidence intervals
    # from sets of already calculated by country/by survey scores
    
    if (show_summary) {
      # calculate
      ds_ci <- ds %>%
        group_by(year_term) %>%
        summarise(
          term_ave = mean(id_term, na.rm = TRUE),
          term_sd = sd(id_term, na.rm = TRUE),
          term_sem = sd(id_term, na.rm = TRUE) / sqrt(n()),
          term_med = median(id_term, na.rm = TRUE),
          n = n()
        ) %>%
        mutate(
          term_lwr.ci = term_ave - qt(1 - (plevel / 2), n - 1) * term_sem,
          term_upr.ci = term_ave + qt(1 - (plevel / 2), n - 1) * term_sem,
          cntry_label = NA
        )
      
      # for the labels / legends
      ci_pct <- round((1 - plevel) * 100, 0)
      loess_color <- "gray"
      txt_subhead <- paste0(txt_subhead)
      txt_caption <-
        paste0(
          "Mean (with ", ci_pct, 
          "% CI) in black, Median = red diamond, loess fit = ",
          loess_color,
          " line\n",
          txt_caption
        )
    } else {
      ds_ci <- NULL
    }
    
    first_year <- min(ds$year_term)
    last_year <- max(ds$year_term)
    
    # legends
    ds <- ds %>%
      group_by(cntry_term) %>%
      arrange(desc(year_term)) %>%
      filter(!is.na(id_term)) %>%
      mutate(n_rows = n()) %>%
      mutate(cntry_label = ifelse(row_number() == 1 |
                                    row_number() == n_rows, cntry_term, NA)) %>%
      arrange(year_term) %>%
      ungroup()
    
    
    p_ci <- ggplot(data = ds, aes(x = year_term, label = cntry_label))
    
    # if needed, add confidence intervals, mean and median, data points and loess fit
    if (show_summary) {
      p_ci <- p_ci +
        # loess fit for the average
        geom_smooth(
          method = "loess",
          aes(y = id_term),
          alpha = 0.25,
          se = FALSE,
          size = 3,
          color = loess_color
        ) +
        # median and mean with error bars
        geom_point_interactive(
          data = ds_ci,
          aes(y = term_med,
              tooltip = paste("Median", round(term_med, 2))),
          pch = 18,
          color = "red",
          cex = 4
        ) +
        geom_point_interactive(data = ds_ci, 
                               aes(y = term_ave,
                                   tooltip = paste("Mean", round(term_ave, 2)))) +
        geom_errorbar(data = ds_ci,
                      aes(ymin = term_lwr.ci, 
                          ymax = term_upr.ci),
                      width = 0.25)
    }
    
    p_ci <- p_ci +
      # individual scores linked with line
      geom_point_interactive(aes(
        y = id_term,
        color = cntry_term,
        data_id = cntry_term,
        tooltip = paste(cntry_term, round(id_term, 2))
      ),
      alpha = 0.5) +
      geom_line_interactive(
        aes(
          y = id_term,
          color = cntry_term,
          data_id = cntry_term,
          tooltip = cntry_term
        ),
        alpha = 0.5,
        size = 0.3
      ) +
      # labels
      geom_text_repel(
        aes(y = id_term, color = cntry_term),
        size = 3*label_size_coef,
        force = 10,
        # xlim = c(last_year, NA),
        arrow = arrow(
          length = unit(0.02, "npc"),
          type = "closed",
          ends = "last"
        )
      ) +
      # need room for the country names
      xlim(c(
        first_year - 0.2 * (last_year - first_year),
        last_year + 0.2 * (last_year - first_year)
      )) +
      # legends
      labs(title = txt_head,
           subtitle = txt_subhead,
           caption = txt_caption) +
      xlab("") + ylab("") +
      scale_color_viridis(discrete=TRUE) +
      theme(
        legend.position = "None",
        plot.title = element_text(hjust = 0),
        plot.subtitle = element_text(hjust = 0),
        plot.caption = element_text(size = 8)
      )
    
    return(list("ci" = p_ci, "ds_ci" = ds_ci))
  }

# convert left skewed data in 0-10 range into normal
# range - Note: inverts order where 10 = 0 and 0 =  
ReflectLnTransform <- function(v, v_max=10){
  log(v_max+1-v)
}

# get an overview on an indicator for a country and year
PlotIndicatorHistogram <- function(ds, 
                                   this_cntry, 
                                   yr, 
                                   this_indicator,
                                   use_transform = "",
                                   n_bins = 10,
                                   title_size = 10) {
  
  if (!(this_indicator %in% colnames(ds))) stop(paste("cannot find", this_indicator))
  
  colnames(ds)[colnames(ds)==this_indicator] <- "myindicator"
  ds <- ds %>% filter(!is.na(myindicator))          # excluding missing data
  if(this_cntry != "") ds <- ds %>% filter(cntry_name == this_cntry)
  if(!is.na(yr)) ds <- ds %>% filter(ess_year == yr)
  
  if (use_transform != ""){
    if (use_transform != "ReflectLn") stop("Only ReflectLn or none!!")
    ds$myindicator <- ReflectLnTransform(ds$myindicator)
    mymarkers <- 0:10
    mymarkers_log <- ReflectLnTransform(mymarkers)
    p <- ggplot(data = ds) +
      geom_histogram(aes(myindicator, weight = pspwght), bins = n_bins, fill = "gray") +
      geom_vline(xintercept = mymarkers_log, linetype = "dotted", color = "red") +
      annotate("text", x=mymarkers_log, y=30, label=mymarkers, 
               size = as.integer(0.3 * title_size), color="red")
  } else {
    p <- ggplot(data = ds) +
      geom_histogram(aes(myindicator, weight = pspwght), bins = n_bins, fill = "gray")
  }
  
  # summary statistics 
  w_mean <- Weighted.Desc.Stat::w.mean(ds$myindicator, ds$pspwght)
  w_sd <- Weighted.Desc.Stat::w.sd(ds$myindicator, ds$pspwght)
  w_var <- Weighted.Desc.Stat::w.var(ds$myindicator, ds$pspwght)
  w_skewness <- Weighted.Desc.Stat::w.skewness(ds$myindicator, ds$pspwght)
  
  # making normal curve
  n <- nrow(ds)
  binwidth <- abs(max(ds$myindicator)-min(ds$myindicator))/n_bins
  
  p <- p +
    stat_function(fun = function(x) dnorm(x, mean = w_mean, sd = w_sd) * n * binwidth,
                  color = "darkred", size = 1)
  
  # the plot
  p <- p +
    geom_vline(xintercept = w_mean, color="blue", linetype="dashed", size=1) +
    geom_vline(xintercept = c(w_mean-w_sd, w_mean+w_sd) , color="blue", linetype="dotted", size=0.5) +
    labs(
      title = paste("Weighted", use_transform, this_indicator, "/", this_cntry, "/", yr),
      subtitle = paste0("Mean: ", round(w_mean, 2),
                        ", SD: ", round(w_sd, 2),
                        ", Var: ", round(w_var, 2),
                        ", Skew: ", round(w_skewness, 2)),
      caption = "Mean and +- 1SD marked on plot, ESS surveys 2002-2016"
    ) +
    theme(
      axis.title = element_blank(),
      plot.title = element_text(size = title_size, hjust = 0),
      plot.subtitle = element_text(size = as.integer(0.8 * title_size), hjust = 0),
      axis.text = element_text(size = as.integer(0.7 * title_size)),
      plot.caption = element_text(size = as.integer(0.8 * title_size))
    )
  
  
  return(p)
}

# compare significance of change in mean between two pairs of dates: 2002-2016, 2014, 2016
CreateComparisonTable021416 <- function(ds_averages, ds_raw) {
  # take only the countries included in ds_raw - even if years are fixed
  the_countries <- unique(ds_raw$cntry_name)
  
  GetOneSet <- function(ds, yr){
    set_yr <- (ds %>% filter(ess_year == yr))$indval
    set_yrw <- (ds %>% filter(ess_year == yr))$pspwght
    l_set_yr <- length(set_yr)
    l_set_yrw <- length(set_yrw)
    if (l_set_yr != l_set_yrw) stop(paste("values / weights length mismatch", l_set_yr, l_set_yrw))
    return(list("value"=set_yr, "weight"=set_yrw))
  }
  
  GetTtestW <- function(set_x, set_y, effsize_ci_p = 0.05){
    # Regarding weighted t-test parameters in
    # https://cran.r-project.org/web/packages/weights/weights.pdf
    # 
    # bootse  optional parameter that produces bootstrapped 
    #         standard errors. This should be used to address heteroskadesticity 
    #         issues when weights indicate probabilities of selection 
    #         rather than the precision of estimates.
    # bootp   optional parameter that produces bootstrapped p values instead of
    #         estimating p values from the standard errors. This parameter only operates when
    #         bootse=TRUE.
    # bootn   optional parameter that is used to indicate the number of bootstraps
    #         that should be run for bootse and bootp.
    wtp_x_y <- weights::wtd.t.test(
      x = set_x$value,
      y = set_y$value,
      weight = set_x$weight,
      weighty = set_y$weight,
      bootse = TRUE,
      bootp = TRUE,
      samedata = FALSE,
      alternative = "two.tailed"
    )
    library(effsize)
    effect_size <- effsize::cohen.d(d=set_x$value*set_x$weight, 
                                    f=set_y$value*set_y$weight,
                                    conf.level = effsize_ci_p)
    return(list("t"=wtp_x_y, "effsize"=effect_size))
  }
  
  ret_changes <- ds_averages  %>%
    select(-n) %>%
    filter(ess_year %in% c(2002, 2014, 2016)) %>%
    spread(ess_year, var_ave) %>%
    mutate(d0216 = `2016` - `2002`,
           d1416 = `2016` - `2014`) %>%
    arrange(d0216) %>%
    left_join(do.call(rbind,
                      lapply(the_countries,
                             function(aname,
                                      ds = ds_raw %>%
                                        select(ess_year, cntry_name, indval, pspwght)) {
                               
                               ds_cntry <- ds %>% filter(cntry_name == aname)
                               
                               set_2002 <-GetOneSet(ds_cntry, 2002)
                               set_2014 <-GetOneSet(ds_cntry, 2014)
                               set_2016 <-GetOneSet(ds_cntry, 2016)
                               
                               wtp_2002_2016 <- GetTtestW(set_2002, set_2016)
                               wtp_2014_2016 <- GetTtestW(set_2014, set_2016)
                               
                               GetSigSymbol <- function(x) {
                                 sig <- symnum(
                                   x,
                                   corr = FALSE,
                                   na = FALSE,
                                   cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                                   symbols = c("***", "**", "*", "+", " ")
                                 )
                               }
                               return(
                                 data.frame(
                                   p_0216 = wtp_2002_2016$t$coefficients["p.value"],
                                   sig_0216 = GetSigSymbol(wtp_2002_2016$t$coefficients["p.value"]),
                                   eff_0216 = wtp_2002_2016$effsize$estimate,
                                   eff_cil_0216 = wtp_2002_2016$effsize$conf.int[1],
                                   eff_ciu_0216 = wtp_2002_2016$effsize$conf.int[2],
                                   eff_m_0216 = wtp_2002_2016$effsize$magnitude,
                                   p_1416 = wtp_2014_2016$t$coefficients["p.value"],
                                   sig_1416 = GetSigSymbol(wtp_2014_2016$t$coefficients["p.value"]),
                                   eff_1416 = wtp_2002_2016$effsize$estimate,
                                   eff_cil_1416 = wtp_2002_2016$effsize$conf.int[1],
                                   eff_ciu_1416 = wtp_2002_2016$effsize$conf.int[2],
                                   eff_m_1416 = wtp_2002_2016$effsize$magnitude,
                                   cntry_name = aname
                                 )
                               )
                             })))
  return(ret_changes %>% 
           select(cntry_name, `2002`, `2014`, `2016`, 
                  d0216, eff_cil_0216 , eff_ciu_0216, eff_m_0216, p_0216, sig_0216, 
                  d1416, eff_cil_1416 , eff_ciu_1416, eff_m_1416, p_1416, sig_1416))
}


# changes between selected surveys - only for countries which were in 2002, 2014, 2016 
GetComparisonBoxPlot <- function(indval_name, ds_avg, ds, cntry_list, skip_plot=FALSE) {
  
  ds <- ds %>% filter(cntry_name %in% cntry_list)
  ds_avg <- ds_avg %>% filter(cntry_name %in% cntry_list)
  
  colnames(ds)[colnames(ds)==indval_name] <- "indval"
  
  # table  
  indval_changes <- CreateComparisonTable021416(ds_averages = ds_avg, ds_raw = ds)
  
  if (skip_plot){
    p <- NULL
  } else {
    
    # Need a plot 
    indval_changes_avg <- indval_changes %>%
      gather(ess_year,mean,c(`2002`, `2014`, `2016`)) %>%
      mutate(cntry_yr = paste(cntry_name, ess_year))
    
    p <- ggplot(ds %>% 
                  filter(ess_year %in% c(2002, 2014, 2016)) %>% 
                  mutate(cntry_yr = paste(cntry_name, ess_year)),
                aes(x=cntry_yr, y=indval, weight = pspwght, fill=cntry_name)) + 
      geom_boxplot_interactive(width=0.6,  colour = I("#3366FF"), 
                               aes(tooltip=paste(cntry_name, ess_year))) +
      geom_point_interactive(data=indval_changes_avg, 
                             aes(x=cntry_yr, y=mean,
                                 tooltip=paste0(cntry_yr,"\nMean: ", round(mean,2))),
                             shape = 23, 
                             size = 1.5, fill ="white",inherit.aes=FALSE) + 
      theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 6),
            axis.title=element_blank(),
            plot.title = element_text(hjust = 0),
            plot.subtitle = element_text(hjust = 0)) + 
      guides(fill=FALSE) +
      labs(title = "Subjective happiness 2002, 2014 and 2016",
           subtitle = "Boxplot with mean (using weighted data, for countries participating all surveys)",
           caption = "ESS surveys 2002-2016")
  }
  
  return(list("plot"=p, "table"=indval_changes))
  
}



# helpers to identify columns with / without NA values
not_all_na <- function(x)
  any(!is.na(x))
not_any_na <- function(x)
  all(!is.na(x))

# Defining a helper function to make correlation matrix easy to reproduce.
PlotOneCorrMtx <-
  function(ds2,
           txt_header,
           sig_level,
           axis_txt_size = 8) {
    ds2 <- ds2  %>% select_if(not_any_na)
    cormat <- rcorr(as.matrix(ds2))
    p <- ggcorrplot(
      cormat$r,
      type = "upper",
      hc.order = TRUE,
      p.mat = cormat$P,
      sig.level = sig_level,
      tl.cex = axis_txt_size,
      insig = "blank"
    ) +
      labs(title = txt_header,
           subtitle = paste0("Signif level: ", sig_level)) +
      theme(
        plot.title = element_text(hjust = 0),
        plot.subtitle = element_text(hjust = 0)
      )
    return(list("cormat" = cormat, "p" = p))
  }


# get characteristics of linear easily into the plot subtitle
GetFitCharacteristics <- function(thefit, the_member) {
  p_val <- summary(thefit)$coefficients[the_member, "Pr(>|t|)"]
  std_err <- summary(thefit)$coefficients[the_member, "Std. Error"]
  adj_rsq <- summary(thefit)$adj.r.squared
  return(paste(
    "p",
    round(p_val, 3),
    "stderr",
    round(std_err, 3),
    "adj rsq",
    round(adj_rsq, 3)
  ))
}



# https://stackoverflow.com/questions/45793683/r-determine-goodness-of-fit-of-new-data-with-predict-function-based-on-existin

r_squared <- function(vals, preds) {
  1 - (sum((vals - preds) ^ 2) / sum((vals - mean(preds)) ^ 2))
}

r_squared_a <- function(vals, preds, k) {
  1 - ((1 - r_squared(vals, preds)) * (length(preds) - 1)) / (length(preds) - k - 1)
}


#
# Handling caption and table numbering
# Ref: https://datascienceplus.com/r-markdown-how-to-number-and-reference-tables/
#

table_nums <- captioner::captioner(prefix = "Tab.")
figure_nums <- captioner::captioner(prefix = "Fig.")

f.ref <- function(x) {
  stringr::str_extract(table_nums(x), "[^:]*")
}